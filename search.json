[{"title":"centos7切换国内源","url":"/2022/06/29/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/","content":"<p>如果想仅使用新设置的国内源，可以先备份原先的源文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># cd /etc/yum.repos.d</span><br><span class=\"line\"># mkdir repo_bak</span><br><span class=\"line\"># mv *.repo repo_bak/</span><br></pre></td></tr></table></figure>\n\n<p>使用阿里云Yum源（CentOS7):</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># wget -O /etc/yum.repos.d/CentOS7-Aliyun.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class=\"line\"># wget -O /etc/yum.repos.d/epel-7-Aliyun.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure>\n\n<p>更新缓存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># yum clean all</span><br><span class=\"line\"># yum makecache</span><br><span class=\"line\">#查看源列表</span><br><span class=\"line\"># yum repolist all</span><br></pre></td></tr></table></figure>\n","categories":["综合"],"tags":["Linux"]},{"title":"CommonJS 详细介绍","url":"/2020/03/07/commonjs/","content":"<h2 id=\"CommonJS-规范与实现\"><a href=\"#CommonJS-规范与实现\" class=\"headerlink\" title=\"CommonJS 规范与实现\"></a>CommonJS 规范与实现</h2><p>正如当年为了统一 JavaScript 语言标准，人们制定了 ECMAScript 规范一样，如今为了统一 JavaScript 在浏览器之外的实现，CommonJS 诞生了。CommonJS 试图定义一套普通应用程序使用的 API，从而填补 JavaScript 标准库过于简单的不足。CommonJS 的终极目标是制定一个像 C++ 标准库一样的规范，使得基于 CommonJS API 的应用程序可以在不同的环境下运行，就像用 C++ 编写的应用程序可以使用不同的编译器和运行时函数库一样。为了保持中立，CommonJS 不参与标准库实现，其实现交给像 Node.js 之类的项目来完成。下图是 CommonJS 的各种实现。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"http://i2.muimg.com/567571/abd3d52d96d4db7c.png\" alt=\"ConmonJS 的实现\"></p>\n<p>CommonJS 规范包括了模块（modules）、包（packages）、系统（system）、二进制（binary）、控制台（console）、编码（encodings）、文件系统（filesystems）、套接字（sockets）、单元测试（unit testing）等部分。</p>\n<p>Node.js 是目前 CommonJS 规范最热门的一个实现，它基于 CommonJS 的 Modules&#x2F;1.0 规范实现了 Node.js 的模块，同时随着 CommonJS 规范的更新，Node.js 也在不断跟进。</p>\n<p>模块（Module）和包（Package）是 Node.js 最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正式为了实现这种方式而诞生的。在浏览器 JavaScript 中，脚本模块的拆分和组合通常使用 HTML 的 script 标签来实现。Node.js 提供了 require 函数来调用其他模块，而且模块都是基于文件的，机制十分简单。</p>\n<h2 id=\"CommonJS-规范的实现\"><a href=\"#CommonJS-规范的实现\" class=\"headerlink\" title=\"CommonJS 规范的实现\"></a>CommonJS 规范的实现</h2><p>Node.js 的模块和包机制的实现参照了 CommonJS 的标准，但并未完全遵循。不过两者的区别不大，一般来说你大可不必担心，只有当你试图制作一个除了支持 Node.js 之外还要支持其他平台的模块或包的时候才需要仔细研究。通常，两者没有直接冲突的地方。</p>\n<p>我们经常把 Node.js 的模块和包相提并论，因为模块和包是没有本质区别的，两个概念也时常混用。如果要辨析，那么可以<strong>把包理解成是实现了某个功能模块的集合</strong>，用于发布和维护。对使用者来说，模块和包的区别是透明的，因此经常不作区分。</p>\n<p>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。</p>\n<p>为了方便，Node.js 为每个模块提供一个 exports 变量，指向 module.exports。这等同在每个模块头部，有一行这样的命令：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">exports</span> = <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>;</span><br></pre></td></tr></table></figure>\n<p>注意，不能直接将 exports 变量指向一个值，因为这样等于切断了 exports 与 module.exports 的联系。</p>\n<p><strong>如果你觉得，exports 与 module.exports 之间的区别很难分清，一个简单的处理办法，就是放弃使用 exports，只使用 module.exports。</strong></p>\n<h2 id=\"什么是模块\"><a href=\"#什么是模块\" class=\"headerlink\" title=\"什么是模块\"></a>什么是模块</h2><p>模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C&#x2F;C++ 扩展。</p>\n<h2 id=\"创建及加载模块\"><a href=\"#创建及加载模块\" class=\"headerlink\" title=\"创建及加载模块\"></a>创建及加载模块</h2><h3 id=\"创建模块\"><a href=\"#创建模块\" class=\"headerlink\" title=\"创建模块\"></a>创建模块</h3><p>在 Node.js 中，创建一个模块非常简单，因为一个文件就是一个模块，我们要关注的问题仅仅在于如何在其他文件中获取这个模块。Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。<br>让我以一个例子来了解模块。创建一个 module.js 文件，内容是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// module.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">setName</span> = <span class=\"keyword\">function</span>(<span class=\"params\">thyName</span>) &#123;</span><br><span class=\"line\">    name = thyName;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello &#x27;</span> + name);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在同一目录下创建 getmodule.js，内容是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// getmodule.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myModule = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./module&#x27;</span>);</span><br><span class=\"line\">myModule.<span class=\"title function_\">setName</span>(<span class=\"string\">&#x27;Yu&#x27;</span>);</span><br><span class=\"line\">myModule.<span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure>\n\n<p>运行 <code>node getmodule.js</code> ，结果是：</p>\n<blockquote>\n<p>Hello Yu</p>\n</blockquote>\n<p>module.js 通过 exports 对象把 setName 和 sayHello 作为模块的访问接口，在 getmodule.js 中通过 <code>require(&#39;./module&#39;)</code> 加载这个模块，然后就可以直接访问 module.js 中 exports 对象的成员函数了。</p>\n<h3 id=\"加载模块\"><a href=\"#加载模块\" class=\"headerlink\" title=\"加载模块\"></a>加载模块</h3><blockquote>\n<p>在 Node.js 中，我们可以直接通过 require 获取核心模块，例如 <code>require(&#39;fs&#39;)</code> 。核心模块拥有最高的加载优先级，换言之如果有模块与其命名冲突，Node.js 总是会加载核心模块。</p>\n</blockquote>\n<p>如果有模块与核心模块命名冲突，Node.js 为什么可以选择加载核心模块呢？require 的实现机制是怎样的呢？</p>\n<h4 id=\"1、按路径加载模块\"><a href=\"#1、按路径加载模块\" class=\"headerlink\" title=\"1、按路径加载模块\"></a>1、按路径加载模块</h4><p>如果 require 参数以 “&#x2F;“ 开头，那么就以绝对路径的方式查找模块名称，例如 <code>require(&#39;/home/neveryu/module&#39;)</code> 将会按照 优先级依次尝试加载 <code>/home/neveryu/module.js</code>、<code>/home/neveryu/module.json</code> 和 <code>/home/neveryu/module.node</code>。</p>\n<p>如果 require 参数 “.&#x2F;“ 或 “..&#x2F;“ 开头，那么则以相对路径的方式查找模块，这种方式在应用中是最常见的。例如前面的例子中我们用了 <code>require(&#39;./hello&#39;)</code>来加载同一文件夹下的 hello.js。</p>\n<h4 id=\"2、通过查找-node-modules-目录加载模块\"><a href=\"#2、通过查找-node-modules-目录加载模块\" class=\"headerlink\" title=\"2、通过查找 node_modules 目录加载模块\"></a>2、通过查找 node_modules 目录加载模块</h4><p>如果 require 参数不以 “&#x2F;“ ， “.&#x2F;“ 或 “..&#x2F;“ 开头，而该模块又不是核心模块，那么就要通过查找 node_modules 加载模块了。我们使用 npm 获取的包通常就是以这种方式加载的。<br>在 node_modules 目录的外面一层，外面可以直接使用 <code>require(&#39;express&#39;)</code> 来代替 <code>require(&#39;./node_modules/express&#39;)</code>。这是 Node.js 模块加载的一个重要特征：通过查找 node_modules 目录来加载模块。<br>我们不仅要在 project 目录下的 app.js 中使用 <code>require(&#39;express&#39;)</code>，而且可能要在 controllers 子目录下的 index_controller.js 中也使用 <code>require(&#39;express&#39;)</code>，这时就需要向父目录上溯一层才能找到 node_modules 中的 express 了。</p>\n<h4 id=\"3、加载缓存\"><a href=\"#3、加载缓存\" class=\"headerlink\" title=\"3、加载缓存\"></a>3、加载缓存</h4><p>Node.js 通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了。注意，Node.js 是根据实际文件名缓存的，而不是 require() 提供的参数缓存的，也就是说即使你分别通过 <code>require(&#39;express&#39;)</code> 和 <code>require(&#39;./node_modules/express&#39;)</code>加载两次，也不会重复加载，因为尽管两次参数不同，解析到的文件却是同一个。</p>\n<h3 id=\"单次加载\"><a href=\"#单次加载\" class=\"headerlink\" title=\"单次加载\"></a>单次加载</h3><p>上面这个例子有点类似于创建一个对象，但实际上和对象又有本质的区别，因为 require 不会重复加载模块，也就是说无论调用多少次 require，获得的模块都是同一个。我们在 getmodule.js 的基础上稍作修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// loadmodule.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hello1 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./module&#x27;</span>);</span><br><span class=\"line\">hello1.<span class=\"title function_\">setName</span>(<span class=\"string\">&#x27;Yu&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hello2 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./module&#x27;</span>);</span><br><span class=\"line\">hello2.<span class=\"title function_\">setName</span>(<span class=\"string\">&#x27;Yu 2&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">hello1.<span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure>\n\n<p>运行后发现输出结果是 Hello Yu 2，这是因为变量 hello1 和 hello2 指向的是同一个实例，因此 hello1.setName 的结果被 hello2.setName 覆盖，最终输出结果是由后者决定的。</p>\n<h3 id=\"覆盖-exports\"><a href=\"#覆盖-exports\" class=\"headerlink\" title=\"覆盖 exports\"></a>覆盖 exports</h3><p>有时候我们只是想把一个对象封装到模块中，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// singleobjct.js</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Hello</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">setName</span> = <span class=\"keyword\">function</span> (<span class=\"params\">thyName</span>) &#123;</span><br><span class=\"line\">        name = thyName;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello &#x27;</span> + name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">Hello</span> = <span class=\"title class_\">Hello</span>;</span><br></pre></td></tr></table></figure>\n<p>此时我们在其他文件中需要通过 <code>require(&#39;./singleobject&#39;).Hello</code> 来获取 Hello 对象，这略显冗余，可以用下面方法稍微简化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.js</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Hello</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">setName</span> = <span class=\"keyword\">function</span>(<span class=\"params\">thyName</span>) &#123;</span><br><span class=\"line\">    name = thyName;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello &#x27;</span> + name);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title class_\">Hello</span>;</span><br></pre></td></tr></table></figure>\n<p>这样就可以直接获得这个对象了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// gethello.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Hello</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./hello&#x27;</span>);</span><br><span class=\"line\">hello = <span class=\"keyword\">new</span> <span class=\"title class_\">Hello</span>();</span><br><span class=\"line\">hello.<span class=\"title function_\">setName</span>(<span class=\"string\">&#x27;Yu&#x27;</span>);</span><br><span class=\"line\">hello.<span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Tip\"><a href=\"#Tip\" class=\"headerlink\" title=\"Tip\"></a>Tip</h2><h3 id=\"CommonJS-模块的特点如下：\"><a href=\"#CommonJS-模块的特点如下：\" class=\"headerlink\" title=\"CommonJS 模块的特点如下：\"></a>CommonJS 模块的特点如下：</h3><ol>\n<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>\n<li>独立性是模块的重要特点就，模块内部最好不与程序的其他部分直接交互。</li>\n<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>\n<li>模块加载的顺序，按照其在代码中出现的顺序。</li>\n</ol>\n<h3 id=\"CommonJS-中的-Require\"><a href=\"#CommonJS-中的-Require\" class=\"headerlink\" title=\"CommonJS 中的 Require\"></a>CommonJS 中的 Require</h3><p>建议阅览：<a href=\"http://wiki.commonjs.org/wiki/Modules/1.1.1#Require\">CommonJS require 规范</a></p>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"Git学习总结","url":"/2021/10/07/git/","content":"<h2 id=\"git-简介\"><a href=\"#git-简介\" class=\"headerlink\" title=\"git 简介\"></a>git 简介</h2><p>git 是分布式的，所以其核心就是分支，分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到 master 分支，master 分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。<br>在 git 中，工作目录下面的所有文件都不外乎这两种状态：<strong>已跟踪</strong>或<strong>未跟踪</strong>。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"实用指令详解\"><a href=\"#实用指令详解\" class=\"headerlink\" title=\"实用指令详解\"></a>实用指令详解</h2><h3 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h3><p>通常，合并分支时，如果可能，Git 会用 Fast froward 模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用 Fast forward 模式，Git 就会在 merge 时生成一个新的 commit ，这样，从分支历史上就可以看出分支信息。<br><code>git merge --no-ff -m &#39;merge  with no-ff&#39; dev</code><br>因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。</p>\n<p>合并分支时，加上 <code>--no-ff</code> 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。</p>\n<h3 id=\"fetch\"><a href=\"#fetch\" class=\"headerlink\" title=\"fetch\"></a>fetch</h3><p>一旦远程主机的版本库有了更新(git 术语叫做 commit)，需要将这些更新取回本地，这时就要用到 git fetch 命令。<br><code>git fetch &lt;远程主机名&gt;</code><br>上面命令将某个远程主机的更新，全部取回本地。<br>默认情况下，git fetch 取回所有分支(branch)的更新。如果只想取回特定分支的更新，可以指定分支名。<br><code>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code><br>比如，取回 origin 主机的 master 分支<br><code>git fetch origin master</code><br>所取回的更新，在本地主机上要用“远程主机名&#x2F;分支名”的形式读取。比如 origin 主机的 master，就要用 origin&#x2F;master 读取。</p>\n<p><code>git fetch -p</code> ：取回远程更新，删除不存在的分支。</p>\n<h3 id=\"pull\"><a href=\"#pull\" class=\"headerlink\" title=\"pull\"></a>pull</h3><p>git pull 命令的作用是，取回远程主机的某个分支的更新，再与本地的指定分支合并，完整格式如下：<br><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code><br>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。<br><code>git pull origin next:master</code><br>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。<br><code>git pull origin master</code><br>上面的命令表示，取回 origin&#x2F;master 分支，再与当前分支合并。实质上，这等同于先做 git fetch，再 merge。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git fetch origin</span><br><span class=\"line\">git merge origin/master</span><br></pre></td></tr></table></figure>\n<p>在某些场合，git 会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在 git clone 的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的 master 分支自动“追踪” origin&#x2F;master 分支。<br>git 也允许手动建立追踪关系。<br><code>git branch --set-upstream master origin/next</code><br>上面的命令指定 master 分支追踪 origin&#x2F;next 分支。<br>如果当前分支与远程分支存在追踪关系，git pull 就可以省略远程分支名。<br><code>git pull origin</code><br>上面命令表示，本地的当前分支自动与对应的 origin 主机“追踪分支”(remote-tracking branch)进行合并。<br>如果当前分支只有一个追踪分支，连远程主机名都可以忽略。<br><code>git pull</code><br>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。<br>如果合并需要采用 rebase 模式，可以使用 -rebase 选项。<br><code>git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p>\n<h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h3><p>git push 命令用于将本地分支的更新，推送到远程主机。它的格式与 git pull 命令相仿。<br><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><br>如果省略远程分支名，则表示将本地分支推送与之存在“追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。<br><code>git push origin master</code><br>上面命令表示，将本地的 master 分支推送到 origin 主机的 master 分支。如果后者不存在，则会被新建。<br><strong>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</strong><br><code>git push origin :master</code><br>等同于<br><code>git push origin --delete master</code><br>上面命令表示删除 origin 主机的 master 分支。<br>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。<br><code>git push origin</code><br>上面命令表示，将当前分支推送到 origin 主机的对应分支。<br>如果当前分支只有一个追踪分支，那么主机名都可以省略。<br><code>git push</code><br>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用 git push 。<br><code>git push -u origin master</code><br>上面的命令将本地 master 分支推送到 origin 主机，同时指定 origin 为默认主机，后面就可以不加任何参数使用 git push 了。<br>不带任何参数的 git push ，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。<br>git 2.0 版本之前，默认采用 matching 方式，现在改为默认采用 simple 方式，如果要修改这个设置，可以采用 git config 命令。<br><code>git config --global push.default matching</code><br>或者<br><code>git config --global push.default simple</code><br>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 -all 选项。<br><code>git push --all origin</code><br>上面命令表示，将所有本地分支都推送到 origin 主机。<br>如果远程主机的版本比本地版本更新，推送时 git 会报错，要求先在本地做 git pull 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 -force 选项。<br><code>git push --force origin</code><br>上面命令使用-force选项，结果导致在远程主机产生一个“非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用 -force 选项。<br>最后，git push 不会推送标签(tag)，除非使用 -tags 选项。<br><code>git push origin --tags</code></p>\n<h3 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h3><p><code>git log</code> 命令可以查看历史记录，<code>git log</code> 命令显示从最近到最远的提交日志；<br>如果嫌输出信息太多，看得眼花缭乱的，可以试试 <code>git log --pretty=oneline</code> 。我们可以看到当前版本以及之前的版本日志以及版本号。<br>用 <code>git log --graph</code> 命令可以看到分支合并图。<br>或者两个参数一起用：<br><code>git log --graph --pretty=oneline</code><br><code>git log --graph --pretty=oneline --abbrev-commit</code><br>首先，git 必须知道当前版本是哪个版本，在 git 中，用 HEAD 表示当前版本，上一个版本就是 <code>HEAD^</code> ，上上一个版本就是 <code>HEAD^^</code> ， 当然往上100个版本写100个 <code>^</code> 比较容易数不过来，所以写成 <code>HEAD~100</code> 。<br>现在，我们要把当前版本回退到上一个版本，就可以使用 <code>git reset</code> 命令：<br><code>git reset --hard HEAD^</code><br>当你回退到了某个版本后，<code>git log</code> 只能显示此版本及之前的版本的日志，之后的版本日志就看不到了，但是，我们想恢复到之后教新的版本怎么办？<br>Git 提供了一个命令 <code>git reflog</code> 用来记录你的每一次命令</p>\n<h3 id=\"tag\"><a href=\"#tag\" class=\"headerlink\" title=\"tag\"></a>tag</h3><p>查看标签（用来标记标志性的稳定版本信息）<br>发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>相比于 commit 的版本号(40位16进制)，标签号则要好使的多。<br>所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑定在一起。</p>\n<p><code>git tag [tag name]</code><br>如果没有标签名，则为查看所有标签，带标签名则为新建标签</p>\n<p><code>git tag &lt;tag name&gt;</code> 就可以打一个新标签</p>\n<p>还可以创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字。<br><code>git tag -a &lt;tag name&gt; -m &lt;comment&gt;</code> ：添加带注释的标签<br>eg: <code>git tag -a v1.2 -m &#39;version 1.2 released&#39;</code></p>\n<p><code>git tag -a &lt;tag name&gt; &lt;md5&gt;</code> ：对某个版本打标签<br>默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？<br>方法是找到历史提交的 commit id，然后打上就可以了。<br><code>git log --pretty=oneline --abbrev-commit</code><br>比方说要对 add merge 这次提交打标签，它对应的 commit id 是 6224937，那么我们就可以使用命令：<br><code>git tag v1.2 6224937</code><br>再用命令 <code>git log</code> 查看标签</p>\n<p>可以用 <code>git show &lt;tagname&gt;</code> 查看标签信息</p>\n<p>如果标签打错了，也可以删除：<br><code>git tag -d v1.2</code></p>\n<p>如果要推送某个标签到远程，使用命令 <code>git push origin &lt;tagname&gt;</code><br>eg: <code>git push origin v1.2</code></p>\n<p>如果标签已经推送到远程，要删除远程标签就要麻烦一点，先从本地删除：<br><code>git tag -d v1.2</code><br>然后，从远程删除；删除命令也是 push ，但是格式如下：<br><code>git push origin :ref/tags/v1.2</code></p>\n<p><code>git tag -l &#39;[expression]&#39;</code><br>查看那符合正则表达式的</p>\n<h3 id=\"stash\"><a href=\"#stash\" class=\"headerlink\" title=\"stash\"></a>stash</h3><p><code>git stash</code><br>备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。<br><code>git stash pop</code><br>从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。<br><code>git stash list</code><br>显示 Git 栈中内的所有备份，可以利用这个列表来决定从哪个地方恢复。<br><code>git stash clear</code> : 清空 Git 栈。</p>\n<p>使用 git 的时候，我们往往使用 branch 解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码，如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码 commit 提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 bug，那么使用 git stash 就可以将你当前未提交到本地的代码推入到 git 的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 bug，等到修完 bug，提交到服务器上后，再使用 git stash apply 将以前一般的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用 git stash 命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑， git stash list 命令可以将当前的 Git 栈信息打印出来，你只需要将找到对应的版本号，例如使用 <code>git stash apply stash@&#123;1&#125;</code> 就可以将你指定版本号为 stash@{1} 的工作取出来，当你将所有的栈都应用回来的时候，可以使用 git stash clear 来将栈清空。<br>在这里顺便提下 git format-patch -n , n是具体某个数字， 例如 ‘git format-patch -1’ 这时便会根据log生成一个对应的补丁，如果 ‘git format-patch -2’ 那么便会生成 2 个补丁，当然前提是你的 log 上有至少有两个记录。</p>\n<p>看过上面的信息，就可以知道使用场合了：当前工作区内容已被修改，但是并未完成。这时 Boss 来了，说前面的分支上面有一个 bug，需要立即修复。可是我又不想提交目前的修改，因为修改没有完成。但是，不提交的话，又没有办法 checkout 到前面的分支。此时用 git stash 就相当于备份了工作区了。然后在 checkout 过去修改，就能够达到保存当前工作区，并及时恢复的作用。</p>\n<p>注意这里由于只 stash 了一次所以要使用 pop，具体你存放了多少。</p>\n<h3 id=\"remote\"><a href=\"#remote\" class=\"headerlink\" title=\"remote\"></a>remote</h3><p>查看远程仓库名</p>\n<p><code>git remote -v</code><br>查看远程仓库url</p>\n<p><code>git remote add &lt;basename&gt; &lt;url&gt;</code><br>新增远程仓库</p>\n<p><code>git remote show &lt;basename&gt;</code><br>查看远程仓库详细信息</p>\n<p><code>git remote rename &lt;old basename&gt; &lt;new basename&gt;</code><br>重命名远程仓库</p>\n<h3 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit\"></a>commit</h3><p><code>git commit -a -m &#39;xx&#39;</code><br>暂存并提交</p>\n<h3 id=\"branch\"><a href=\"#branch\" class=\"headerlink\" title=\"branch\"></a>branch</h3><p><code>git branch</code><br>查看本地仓库分支</p>\n<p><code>git branch -r</code><br>查看远程分支情况</p>\n<p><code>git branch -a</code><br>查看本地和远程的所有分支情况</p>\n<p><code>git branch -v</code><br>查看本地仓库分支最后一次提交情况</p>\n<p><code>git branch -vv</code><br>查看分支跟踪情况</p>\n<p><code>git branch &lt;branch name&gt;</code><br>新建分支</p>\n<p><code>git branch -d &lt;branch name&gt;</code><br>删除分支</p>\n<p><code>git branch -D &lt;branch name&gt;</code><br>强制删除分支</p>\n<p><code>git branch [--merged | --no-merged]</code><br>查看已合并|未合并的本地仓库分支</p>\n<p><code>git branch -u &lt;remote base&gt;/&lt;remote branch&gt;</code><br>修改当前跟踪分支</p>\n<h3 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h3><p><code>git checkout -- [file]</code> ：恢复文件<br><code>git checkout -- demo.html</code> 意思就是，把 <code>demo.html</code> 文件在工作区的修改全部撤销，这里有两种情况：<br>一种是 <code>demo.html</code> 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是 <code>demo.html</code> 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加暂存区后的状态。<br>总之，就是让这个文件回到最后一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p>\n<p>但是如果 <code>git add</code> 到暂存区了，在 commit 之前，想撤销：<br>Git 同样告诉我们，用命令 <code>git reset HEAD file</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。<br><code>git reset</code> 命令既可以回退版本，也可以把暂存区的修改回退到工作区，当我们用 <code>HEAD</code> 时，表示最新的版本。<br>再用 <code>git status</code> 查看一下，现在暂存区是干净的，工作区有修改：<br>还记得如果丢弃工作区的修改吗？<br>对的，使用：<code>git checkout -- demo.html</code> </p>\n<p><code>git checkout</code> 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。</p>\n<p><code>git checkout -b [branchname] [tagname]</code><br>在特定的版本上创建一个新的分支并切换到此分支</p>\n<p><code>git checkout -b [local branch] [remote base]/[remote branch]</code><br>将远程分支检出到本地分支，并追踪</p>\n<p><code>git checkout --track &lt;remote base&gt;/&lt;remote branch&gt;</code><br>让当前分支跟踪远程分支</p>\n<h3 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h3><p><code>git rebase [basebranch]</code><br>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"git-clone\"><a href=\"#git-clone\" class=\"headerlink\" title=\"git clone\"></a>git clone</h3><p>git clone 支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等。<br>使用 https 除了速度慢意外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。</p>\n<p><code>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code><br>如果不写本地目录名，默认就是版本库的名字</p>\n<h3 id=\"如何新建分支\"><a href=\"#如何新建分支\" class=\"headerlink\" title=\"如何新建分支\"></a>如何新建分支</h3><p>本地建立 branch 並立即切换到新分支<br><code>git checkout -b &lt;branch_name&gt;</code> </p>\n<p>下面的命令表示，在 <code>origin/master</code> 的基础上，创建一个分支。<br><code>git checkout -b newBranch origin/master</code></p>\n<p>修改分支名称<br><code>git branch -m &lt;new_name&gt;</code></p>\n<h3 id=\"从远程仓库拉取代码到本地仓库，并建立跟踪关系\"><a href=\"#从远程仓库拉取代码到本地仓库，并建立跟踪关系\" class=\"headerlink\" title=\"从远程仓库拉取代码到本地仓库，并建立跟踪关系\"></a>从远程仓库拉取代码到本地仓库，并建立跟踪关系</h3><p><code>git checkout -b &lt;本地新分支名&gt; &lt;对应的远程分支名&gt;</code></p>\n<h3 id=\"如何在远程仓库新建一个分支\"><a href=\"#如何在远程仓库新建一个分支\" class=\"headerlink\" title=\"如何在远程仓库新建一个分支\"></a>如何在远程仓库新建一个分支</h3><p>新建一个本地分支，按照正常流程提交完代码后，推送到远程<br><code>git push &lt;remote base&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code></p>\n<h3 id=\"比较文件\"><a href=\"#比较文件\" class=\"headerlink\" title=\"比较文件\"></a>比较文件</h3><p><code>git diff HEAD -- demo.html</code><br>命令可以查看工作区的 demo.html 和版本库里面最新版本的区别。</p>\n<h3 id=\"忽略某些文件\"><a href=\"#忽略某些文件\" class=\"headerlink\" title=\"忽略某些文件\"></a>忽略某些文件</h3><p>默认方法是在当前项目目录下创建一个 .gitignore 文件，如果需要忽略的文件已经添加到版本库中，请先移除<br><code>git rm --cached [file]</code><br>不删除文件，只移除追踪。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat .gitignore</span><br><span class=\"line\">*.[oa]</span><br><span class=\"line\">*~</span><br></pre></td></tr></table></figure>\n\n<p>文件 .gitignore 的格式规范如下：</p>\n<ul>\n<li>所有空行或者以注释符号 # 开头的目录都会被 git 忽略</li>\n<li>可以使用标准的 glob 模式匹配</li>\n<li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的目录</li>\n<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反</li>\n</ul>\n<h3 id=\"bug-分支\"><a href=\"#bug-分支\" class=\"headerlink\" title=\"bug 分支\"></a>bug 分支</h3><p>git 提供了一个 stash 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。<br><code>git stash</code><br>修改完 bug 后，回到当前分支上继续干活，工作区是干净的，刚才的工作现场存到哪里去了？<br><code>git stash list</code> ：查看 stash 列表(stash 是一个栈的结构)<br>git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法：<br>一是用 <code>git stash apply</code> 恢复，但是恢复后，stash 内容并不删除，你需要用 <code>git stash drop</code> 来删除；<br>另一种方式是用 <code>git stash pop</code> ，恢复的同时把 stash 内容也删了；<br>你可以多次 stash ，恢复的时候，先用 <code>git stash list</code> 查看，然后恢复指定的 stash，用命令：<br><code>git stash apply stash@&#123;0&#125;</code></p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>配置 Git 的时候，加上 –global 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。<br>配置文件放哪了？<br>每个仓库的 Git 配置文件都放在 .git&#x2F;config 文件中，在这份配置文件中，别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。</p>\n<h3 id=\"查看配置\"><a href=\"#查看配置\" class=\"headerlink\" title=\"查看配置\"></a>查看配置</h3><p><code>git config -1</code></p>\n<h3 id=\"设置git-push-默认\"><a href=\"#设置git-push-默认\" class=\"headerlink\" title=\"设置git push 默认\"></a>设置git push 默认</h3><p><code>git config --global push.default current</code></p>\n<h3 id=\"设置别名\"><a href=\"#设置别名\" class=\"headerlink\" title=\"设置别名\"></a>设置别名</h3><p><code>git config --global alias.&lt;name&gt; &lt;commend&gt;</code><br>我的设置：<br><code>git config --global alias.st status</code><br><code>git config --global alias.cm &quot;commit -m&quot;</code><br><code>git config --global alias.ph &quot;push origin &lt;local_repository&gt;:&lt;remote_repository&gt;&quot;</code></p>\n<h3 id=\"保存用户名和密码\"><a href=\"#保存用户名和密码\" class=\"headerlink\" title=\"保存用户名和密码\"></a>保存用户名和密码</h3><h4 id=\"对于http-s-协议，可以用下面命令临时缓存\"><a href=\"#对于http-s-协议，可以用下面命令临时缓存\" class=\"headerlink\" title=\"对于http(s)协议，可以用下面命令临时缓存\"></a>对于http(s)协议，可以用下面命令临时缓存</h4><p><code>git config --global credential.helper cache</code><br>开启linux缓存<br><code>git config --global credential.helper wincred</code><br>开启windows缓存</p>\n<h4 id=\"对于-ssh-协议，可以用-ssh-key，具体教程网上很多\"><a href=\"#对于-ssh-协议，可以用-ssh-key，具体教程网上很多\" class=\"headerlink\" title=\"对于 ssh 协议，可以用 ssh key，具体教程网上很多\"></a>对于 ssh 协议，可以用 ssh key，具体教程网上很多</h4><h2 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h2><h3 id=\"问题一\"><a href=\"#问题一\" class=\"headerlink\" title=\"问题一\"></a>问题一</h3><p>git 中执行命令 <code>add .</code><br>报错：Unlink of file ‘templates&#x2F;opms.exe’ failed.Should I try again?(y&#x2F;n)</p>\n<p>因为这个文件正在被占用，所以不能添加到暂存区，而正好这个 <code>.exe</code> 文件，我们是不需要添加到版本管理工具的。所以我们选择 <code>n</code> 。</p>\n<h3 id=\"问题二\"><a href=\"#问题二\" class=\"headerlink\" title=\"问题二\"></a>问题二</h3><p>git 中生成 sshkey: <code>ssh-keygen -t rsa -C &quot;youremail&quot;</code><br>这个<code>email</code>并没有什么用<br>所以我们使用<code>ssh-keygen -t rsa</code>来生成sshkey就可以了。<br>然后git中的配置文件：<br><code>git config --list</code><br><code>git config --global user.name &quot;yu&quot;</code><br><code>git config --global user.email &quot;react.dong.yu@gmail.com&quot;</code><br>这种配置将会对本地所有的git仓库有效。<br>那么在 push 的时候，远程就知道这个push来自于哪个email.<br>但有时候在公司的时候，有的仓库是公司的，有的仓库是自己github的。<br>这个时候就可以不设置global的配置了，而是在自己的仓库中设置<br><code>git config --local user.email &quot;react.dong.yu@gmail.com&quot;</code></p>\n<h3 id=\"问题三\"><a href=\"#问题三\" class=\"headerlink\" title=\"问题三\"></a>问题三</h3><p>使用 windows 的同学注意了，如果你在资源管理器里新建一个 .gitignore 文件，它会提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 .gitignore 了。<br>有些时候，你想添加一个文件到 git，但发现添加不了，原因是这个文件被 .gitignore 忽略了：<br><code>git add App.class</code><br>如果你确实想添加该文件，可以用 -f 制添加到 git：<br><code>git add -f App.class</code><br>或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了。<br>可以用 <code>git check-ignore</code> 命令检查：<br><code>git check-ignore -v App.class</code></p>\n<h3 id=\"问题四\"><a href=\"#问题四\" class=\"headerlink\" title=\"问题四\"></a>问题四</h3><p>为什么我把我生成的 ssh key 添加到了 github 中<br>然后 也 remote 了 <code>https://github.com/Neveryu/Xxx.git</code><br>为什么提交的时候报错，或者提示 输入密码账号是为什么</p>\n<p>ssh key 是 ssh 协议的密钥，http 协议没权限</p>\n<h3 id=\"问题五\"><a href=\"#问题五\" class=\"headerlink\" title=\"问题五\"></a>问题五</h3><p>git怎样删除未监视的文件 untracked files?<br>用 git clean</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 删除 untracked files</span><br><span class=\"line\">git clean -f</span><br><span class=\"line\"> </span><br><span class=\"line\"># 连 untracked 的目录也一起删掉</span><br><span class=\"line\">git clean -fd</span><br><span class=\"line\"> </span><br><span class=\"line\"># 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）</span><br><span class=\"line\">git clean -xfd</span><br><span class=\"line\"> </span><br><span class=\"line\"># 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删</span><br><span class=\"line\">git clean -nxfd</span><br><span class=\"line\">git clean -nf</span><br><span class=\"line\">git clean -nfd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"我的常用命令\"><a href=\"#我的常用命令\" class=\"headerlink\" title=\"我的常用命令\"></a>我的常用命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch -avv</span><br><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p><a href=\"http://git-scm.com/book/zh/v2\">权威教程</a><br><a href=\"http://iissnan.com/progit/\">Pro Git 简体中文版</a></p>\n","categories":["综合"],"tags":["Git"]},{"title":"腻子脚本 — HTML5Shiv","url":"/2017/01/18/html5shiv/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><a href=\"https://github.com/aFarkas/html5shiv\">HTML5shiv</a> is a javascript workaround to provide support for the new HTML 5 elements in IE Browsers older than IE 9.</p>\n<ul>\n<li>越来越多的站点开始使用 HTML5 标签。但是目前的情况是还有很多人在使用IE6，IE7，IE8。</li>\n<li>而IE6，IE7，IE8是不能识别 HTML5 标签的。</li>\n<li>这里提供一种让 IE 浏览器支持 HTML5 的方法，那就是使用 HTML5Shiv。</li>\n<li>HTML5Shiv 主要解决 HTML5 提出的新的元素不被IE6-8识别。</li>\n</ul>\n<span id=\"more\"></span>\n\n<h1 id=\"为什么要使用-HTML5-的新标签\"><a href=\"#为什么要使用-HTML5-的新标签\" class=\"headerlink\" title=\"为什么要使用 HTML5 的新标签\"></a>为什么要使用 HTML5 的新标签</h1><ul>\n<li><code>&lt;header&gt;</code> 定义页面或区段的头部</li>\n<li><code>&lt;footer&gt;</code> 定义页面或区段的尾部</li>\n<li><code>&lt;nav&gt;</code> 定义页面或区段的导航区域</li>\n<li><code>&lt;section&gt;</code> 页面的逻辑区域或内容组合</li>\n<li><code>&lt;article&gt;</code> 定义正文或一段完整的内容</li>\n<li><code>&lt;aside&gt;</code> 定义补充或相关内容</li>\n</ul>\n<p>使用他们能让代码语义化更直观，而且更方便 SEO 优化，但是此 HTML5 新标签在 IE6&#x2F;IE7&#x2F;IE8 上并不能识别，需要 javascript 处理，所以我们就需要使用目前使用最广泛的 html5shiv.js 了，包括 Bootstrap 框架也是使用的这个来兼容低版本 IE 的。</p>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>　　这些 HTML5 新元素不能被 IE6-8 识别，不能作为父节点包裹子元素，并且不能应用 CSS 样式。让 CSS 样式应用在未知元素上只需执行 <code>document.createElement(elementName)</code> 即可实现。HTML5Shiv 就是根据这个原理创建的。</p>\n<p>关于 HTML5 不得不提 IE，在苹果、Google、Opera 和 Mozilla 等主流浏览器厂商积极参与新版本 HTML 标准的制定和推广时，微软却对 HTML5 规范不屑一顾。然而微软近期才表态要在 IE 中支持 HTML5,以致到今天为止的 IE8 及以下是无法支持 HTML5 标签的.</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>HTML5Shiv 的使用非常的简单，考虑到 IE9 是支持 HTML5 的，所以只需要在页面 head 中添加如下代码即可： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--[if lt IE 9]&gt;</span><br><span class=\"line\">  &lt;script src=&quot;.js/html5shiv.js &quot;&gt;&lt;/script &gt;</span><br><span class=\"line\">&lt;![endif]–-&gt; </span><br></pre></td></tr></table></figure>\n\n<p>The syntax for the HTML5shiv is : </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--[if lt IE 9]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  &lt;script src=&quot;./js/html5shiv.js&quot;&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  &lt;![endif]--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><h2 id=\"注意事项一\"><a href=\"#注意事项一\" class=\"headerlink\" title=\"注意事项一\"></a>注意事项一</h2><p>在引入了 html5shiv.js 以后，还需要在你自己的 css 文件中添加:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span>,<span class=\"selector-tag\">aside</span>,dialog,<span class=\"selector-tag\">footer</span>,<span class=\"selector-tag\">header</span>,<span class=\"selector-tag\">section</span>,<span class=\"selector-tag\">footer</span>,<span class=\"selector-tag\">nav</span>,<span class=\"selector-tag\">figure</span>,<span class=\"selector-tag\">menu</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要是让这些 HTML5 标签成块状,像 div 那样。</p>\n<p>No matter how ways what did you using, you should be initialize the new lable css.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">article</span>,<span class=\"selector-tag\">aside</span>,dialog,<span class=\"selector-tag\">footer</span>,<span class=\"selector-tag\">header</span>,<span class=\"selector-tag\">section</span>,<span class=\"selector-tag\">footer</span>,<span class=\"selector-tag\">nav</span>,<span class=\"selector-tag\">figure</span>,<span class=\"selector-tag\">menu</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项二\"><a href=\"#注意事项二\" class=\"headerlink\" title=\"注意事项二\"></a>注意事项二</h2><p>　　因为 html5shiv.js 是 JavaScript 文件，如果 IE6&#x2F;7&#x2F;8 禁用脚本的用户,那么就变成了无样式的”白板”网页,我们该怎么解决呢?<br>　　我们可以参照 Facebook 的做法，即引导用户进入带有 noscript 标识的页面，用 xhtml 标签替换 html5 标签，这要比为了保持兼容而写大量 hack 的作法更轻便一些。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if lte IE 8]&gt; </span></span><br><span class=\"line\"><span class=\"comment\">&lt;noscript&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;style&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  .html5-wrappers&#123;display:none!important;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/style&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;div class=&quot;ie-noscript-warning&quot;&gt;您的浏览器禁用了脚本，请&lt;a href=&quot;#&quot;&gt;查看这里&lt;/a&gt;来启用脚本!或者&lt;a href=&quot;/?noscript=1&quot;&gt;继续访问&lt;/a&gt;.</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/noscript&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样可以引导用户开启脚本，或者直接跳到 xhtml 标签设计的页面。</p>\n<h2 id=\"注意事项三\"><a href=\"#注意事项三\" class=\"headerlink\" title=\"注意事项三\"></a>注意事项三</h2><ul>\n<li>HTML5shiv is found within the <code>&lt;head&gt;</code> tag.</li>\n<li>HTML5shiv is a javascript file that is referenced in a <code>&lt;script&gt;</code> tag.</li>\n<li>You should usr HTML5shiv when you are using the new HTML5 element such as : <code>&lt;header&gt;</code>,<code>&lt;footer&gt;</code>,<code>&lt;nav&gt;</code>,<code>&lt;aside&gt;</code>,<code>&lt;article&gt;</code></li>\n<li>Download the latest version of HTML5shiv from <a href=\"https://github.com/aFarkas/html5shiv/\">github</a> or reference the Open Source Software CDN version at <code>https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js</code> or <code>https://cdn.bootcss.com/html5shiv/3.7.0/html5shiv.min.js</code>.</li>\n<li>You will require the HTML5shiv to provide compatibility for IE Browser older than IE 9.</li>\n</ul>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><h3 id=\"HTML-5-Document\"><a href=\"#HTML-5-Document\" class=\"headerlink\" title=\"HTML 5 Document\"></a>HTML 5 Document</h3><p>If you created a new web page in HTML5,you would include the HTML5shiv as follows:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--[if lt IE 9]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  &lt;script src=&quot;.js/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>In this HTML 5 Document example,we have added HTML5shiv within the <head> tag.In this case,the HTML5shiv is a javascript file called <strong>html5shiv.js</strong> found in the .&#x2F;js directory.</p>\n<p>If you did not want to download and store the HTML5shiv on your site,you could reference the version found on the Open Source Software CDN site.</p>\n<h3 id=\"Support-two-CDN-site\"><a href=\"#Support-two-CDN-site\" class=\"headerlink\" title=\"Support two CDN site\"></a>Support two CDN site</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>HTML 5 Example by github.com/neveryu<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--[if lt IE 9]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>HTML 5 Example by github.com/neveryu<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--[if lt IE 9]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.0/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项四\"><a href=\"#注意事项四\" class=\"headerlink\" title=\"注意事项四\"></a>注意事项四</h2><h3 id=\"HTML-4-0-1-Transitional-Document\"><a href=\"#HTML-4-0-1-Transitional-Document\" class=\"headerlink\" title=\"HTML 4.0.1 Transitional Document\"></a>HTML 4.0.1 Transitional Document</h3><p>HTML5shiv does not apply to HTML 4.0.1 Transitional.</p>\n<h3 id=\"XHTML-1-0-Transitional-Document\"><a href=\"#XHTML-1-0-Transitional-Document\" class=\"headerlink\" title=\"XHTML 1.0 Transitional Document\"></a>XHTML 1.0 Transitional Document</h3><p>HTML5shiv does not apply to XHTML 1.0 Transitional.</p>\n<h3 id=\"XHTML-1-0-Strict-Document\"><a href=\"#XHTML-1-0-Strict-Document\" class=\"headerlink\" title=\"XHTML 1.0 Strict Document\"></a>XHTML 1.0 Strict Document</h3><p>HTML5shiv does not apply to XHTML 1.0 Strict.</p>\n<h3 id=\"XHTML-1-1-Document\"><a href=\"#XHTML-1-1-Document\" class=\"headerlink\" title=\"XHTML 1.1 Document\"></a>XHTML 1.1 Document</h3><p>HTML5shiv does not apply to XHTML 1.1.</p>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><p>关于低版本浏览器不能识别 HTML5 标签的问题，除了使用 html5shiv.js 之外，还有一种做法就是为网站创建多套模版，通过程序对 User-Agent 的判断给不同的浏览器用户显示不同的页面，比如优酷网就是采用的这种模式。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><a href=\"https://neveryu.github.io/2017/01/18/html5shiv/\">HTML5Shiv</a> and <a href=\"https://neveryu.github.io/2017/02/11/respond-js/\">Respond.js</a> for IE8 support of HTML5 elements and media queries.</p>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"npm 全面介绍","url":"/2019/06/20/npm/","content":"<!-- <img src=\"http://i1.piimg.com/588926/30e7b49044d5cfc4.png\" alt=\"summary-img-src-npm\"> -->\n\n<span id=\"more\"></span>\n\n<h1 id=\"什么是-NPM\"><a href=\"#什么是-NPM\" class=\"headerlink\" title=\"什么是 NPM\"></a>什么是 NPM</h1><p>npm 之于 Node.js ，就像 pip 之于 Python， gem 之于 Ruby， pear 之于 PHP 。</p>\n<p>npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p>\n<h1 id=\"为什么要使用-NPM\"><a href=\"#为什么要使用-NPM\" class=\"headerlink\" title=\"为什么要使用 NPM\"></a>为什么要使用 NPM</h1><p>npm 是随同 Node.js 一起安装的包管理工具，能解决 Node.js 代码部署上的很多问题，常见的场景有以下几种：</p>\n<ul>\n<li>允许用户从 npm 服务器下载别人编写的第三方包到本地使用。</li>\n<li>允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。</li>\n<li>允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。</li>\n</ul>\n<p>npm 的背后，是基于 couchdb 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。</p>\n<h1 id=\"如何使用-NPM\"><a href=\"#如何使用-NPM\" class=\"headerlink\" title=\"如何使用 NPM\"></a>如何使用 NPM</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>npm 不需要单独安装。在安装 Node 的时候，会连带一起安装 npm 。但是，Node 附带的 npm 可能不是最新版本，最后用下面的命令，更新到最新版本。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo npm install npm@latest -g</span><br></pre></td></tr></table></figure>\n<p>如果是 Window 系统使用以下命令即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install npm -g</span><br></pre></td></tr></table></figure>\n<p>也就是使用 npm 安装自己。之所以可以这样，是因为 npm 本身与 Node 的其他模块没有区别。</p>\n<p>然后，运行下面的命令，查看各种信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 npm 命令列表</span></span><br><span class=\"line\">$ npm <span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看各个命令的简单用法</span></span><br><span class=\"line\">$ npm -l</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 npm 的版本</span></span><br><span class=\"line\">$ npm -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看 npm 的配置</span></span><br><span class=\"line\">$ npm config list -l</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"npm-init\"><a href=\"#npm-init\" class=\"headerlink\" title=\"npm init\"></a>npm init</h3><p>npm init 用来初始化生成一个新的 package.json 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。<br>如果使用了 -f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的 package.json 文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm init -y</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"npm-set\"><a href=\"#npm-set\" class=\"headerlink\" title=\"npm set\"></a>npm set</h3><p>npm set 用来设置环境变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm <span class=\"built_in\">set</span> init-author-name <span class=\"string\">&#x27;Your name&#x27;</span></span><br><span class=\"line\">$ npm <span class=\"built_in\">set</span> init-author-email <span class=\"string\">&#x27;Your email&#x27;</span></span><br><span class=\"line\">$ npm <span class=\"built_in\">set</span> init-author-url <span class=\"string\">&#x27;http://yourdomain.com&#x27;</span></span><br><span class=\"line\">$ npm <span class=\"built_in\">set</span> init-license <span class=\"string\">&#x27;MIT&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>上面命令等于为 npm init 设置了默认值，以后执行 npm init 的时候，package.json 的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~&#x2F;.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。</p>\n<h3 id=\"npm-info\"><a href=\"#npm-info\" class=\"headerlink\" title=\"npm info\"></a>npm info</h3><p>npm info 命令可以查看每个模块的具体信息。比如，查看 underscore 模块的信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm info underscore</span><br></pre></td></tr></table></figure>\n<p>上面命令返回一个 JavaScript 对象，包含了 underscore 模块的详细信息。这个对象的每个成员，都可以直接从 info 命令查询。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm info underscore description</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm info underscore homepage</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm info underscore version</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"npm-search\"><a href=\"#npm-search\" class=\"headerlink\" title=\"npm search\"></a>npm search</h3><p>npm search 命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm search &lt;搜索词&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"npm-list\"><a href=\"#npm-list\" class=\"headerlink\" title=\"npm list\"></a>npm list</h3><p>npm list 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加上 global 参数，会列出全局安装的模块</span></span><br><span class=\"line\">$ npm list -global</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># npm list 命令也可以列出单个模块</span></span><br><span class=\"line\">$ npm list underscore</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a>npm install</h3><p>使用 npm 安装包的命令格式为：<br><code>npm [install/i] [package_name]</code></p>\n<h4 id=\"本地模式和全局模式\"><a href=\"#本地模式和全局模式\" class=\"headerlink\" title=\"本地模式和全局模式\"></a>本地模式和全局模式</h4><p>npm 在默认情况下会从 <a href=\"http://npmjs.org/\">http://npmjs.org</a> 搜索或下载包，将包安装到当前目录的 node_modules 子目录下。<br>如果你熟悉 Ruby 的 gem 或者 Python 的 pip，你会发现 npm 与它们的行为不同，gem 或 pip 总是以全局模式安装，使包可以供所有的程序使用，而 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。</p>\n<p>我们在使用 supervisor 的时候使用了 <code>npm install -g supervisor</code> 命令，就是以全局模式安装 supervisor 。</p>\n<p>这里注意一点的就是，supervisor 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 <code>npm config set prefix &quot;路径&quot;</code> 安装完以后就可以用 supervisor 来启动服务了。<br>supervisor 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 Node.js 。</p>\n<p>一般来说，全局安装只适用于工具模块，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为<strong>本地模式不会注册 PATH 环境变量</strong>。<br>“本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。</p>\n<p>本地模式和全局模式的特点如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">模式</th>\n<th align=\"center\">可通过 require 使用</th>\n<th align=\"center\">注册 PATH</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">本地模式</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n</tr>\n<tr>\n<td align=\"center\">全局模式</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 本地安装</span></span><br><span class=\"line\">$ npm install &lt;package name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局安装</span></span><br><span class=\"line\">$ sudo npm install -global &lt;package name&gt;</span><br><span class=\"line\">$ sudo npm install -g &lt;package name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>npm install 也支持直接输入 Github 代码库地址。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install git://github.com/package/path.git</span><br><span class=\"line\">$ npm install git://github.com/package/path.git<span class=\"comment\">#0.1.0</span></span><br></pre></td></tr></table></figure>\n<p>安装之前，npm install 会先检查，node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。</p>\n<p>如果你希望，一个模块不管是否安装过， npm 都要强制重新安装，可以使用 -f 或 –force 参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install &lt;packageName&gt; --force</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装不同版本\"><a href=\"#安装不同版本\" class=\"headerlink\" title=\"安装不同版本\"></a>安装不同版本</h4><p>install 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 @ 和版本号。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install sax@latest</span><br><span class=\"line\">$ npm install sax@0.1.1</span><br><span class=\"line\">$ npm install sax@<span class=\"string\">&quot;&gt;=0.1.0 &lt;0.2.0&quot;</span></span><br></pre></td></tr></table></figure>\n<p>install 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 packages.json 文件的哪一项中。</p>\n<blockquote>\n<p>–save：模块名将被添加到 dependencies，可以简化为参数-S。<br>–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install sax --save</span><br><span class=\"line\">$ npm install node-tap --save-dev</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">$ npm install sax -S</span><br><span class=\"line\">$ npm install node-tap -D</span><br></pre></td></tr></table></figure>\n\n\n<h5 id=\"dependencies-依赖\"><a href=\"#dependencies-依赖\" class=\"headerlink\" title=\"dependencies 依赖\"></a>dependencies 依赖</h5><p>这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 <code>markdown-it</code> 这个包，版本是 <code>^8.1.0</code> ，代表最小依赖版本是 <code>8.1.0</code> ，如果这个包有更新，那么当我们使用 npm install 命令的时候，npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;dependencies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;markdown-it&quot;</span>: <span class=\"string\">&quot;^8.1.0&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"devDependencies-开发依赖\"><a href=\"#devDependencies-开发依赖\" class=\"headerlink\" title=\"devDependencies 开发依赖\"></a>devDependencies 开发依赖</h5><p>在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;devDependencies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;autoprefixer&quot;</span>: <span class=\"string\">&quot;^6.4.0&quot;</span>,<span class=\"number\">0</span><span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span>babel-preset-es2015<span class=\"string\">&quot;: &quot;</span>^<span class=\"number\">6.0</span><span class=\"number\">.0</span><span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span>babel-preset-stage-<span class=\"number\">2</span><span class=\"string\">&quot;: &quot;</span>^<span class=\"number\">6.0</span><span class=\"number\">.0</span><span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span>babel-register<span class=\"string\">&quot;: &quot;</span>^<span class=\"number\">6.0</span><span class=\"number\">.0</span><span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span>webpack<span class=\"string\">&quot;: &quot;</span>^<span class=\"number\">1.13</span><span class=\"number\">.2</span><span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span>webpack-dev-middleware<span class=\"string\">&quot;: &quot;</span>^<span class=\"number\">1.8</span><span class=\"number\">.3</span><span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span>webpack-hot-middleware<span class=\"string\">&quot;: &quot;</span>^<span class=\"number\">2.12</span><span class=\"number\">.2</span><span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span>webpack-merge<span class=\"string\">&quot;: &quot;</span>^<span class=\"number\">0.14</span><span class=\"number\">.1</span><span class=\"string\">&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;</span>highlightjs<span class=\"string\">&quot;: &quot;</span>^<span class=\"number\">9.8</span><span class=\"number\">.0</span><span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>当你有了一个完整的 package.json 文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 npm install 就可以很方便的下载好这个模块所需要的包。</p>\n<p>npm install 默认会安装 dependencies 字段和 devDependencies 字段中的所有模块，如果使用 –production 参数，可以只安装 dependencies 字段的模块。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install --production</span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">$ NODE_ENV=production npm install</span><br></pre></td></tr></table></figure>\n\n<p>一旦安装了某个模块，就可以在代码中用 require 命令加载这个模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> backbone = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;backbone&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(backbone.<span class=\"property\">VERSION</span>)</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"npm-run\"><a href=\"#npm-run\" class=\"headerlink\" title=\"npm run\"></a>npm run</h3><p>npm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。<br>package.json</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;myproject&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;devDependencies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;jshint&quot;</span>: <span class=\"string\">&quot;latest&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;browserify&quot;</span>: <span class=\"string\">&quot;latest&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;mocha&quot;</span>: <span class=\"string\">&quot;latest&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;lint&quot;</span>: <span class=\"string\">&quot;jshint **.js&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;test&quot;</span>: <span class=\"string\">&quot;mocha test/&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"scripts-脚本\"><a href=\"#scripts-脚本\" class=\"headerlink\" title=\"scripts 脚本\"></a>scripts 脚本</h4><p>顾名思义，就是一些脚本代码，可以通过 <code>npm run script-key</code> 来调用，例如在这个 package.json 的文件夹下使用 <code>npm run dev</code> 就相当于运行了 <code>node build/dev-server.js</code> 这一段代码。使用 scripts 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。<br>npm run 是 npm run-script 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 脚本</span></span><br><span class=\"line\"><span class=\"string\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;dev&quot;</span>: <span class=\"string\">&quot;node build/dev-server.js&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build&quot;</span>: <span class=\"string\">&quot;node build/build.js&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;docs&quot;</span>: <span class=\"string\">&quot;node build/docs.js&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build-docs&quot;</span>: <span class=\"string\">&quot;npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\\\* . &amp; git add . &amp; git commit -m &#x27;auto-pages&#x27; &amp; git push &amp; git checkout master&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;build-publish&quot;</span>: <span class=\"string\">&quot;rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;lint&quot;</span>: <span class=\"string\">&quot;eslint --ext .js,.vue src&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>npm run 如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。<br>npm 内置了两个命令简写， npm test 等同于执行 npm run test，npm start 等同于执行 npm run start。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;build&quot;</span>: <span class=\"string\">&quot;npm run build-js &amp;&amp; npm run build-css&quot;</span></span><br></pre></td></tr></table></figure>\n<p>上面的写法是先运行 npm run build-js ，然后再运行 npm run build-css ，两个命令中间用 &amp;&amp; 连接。如果希望两个命令同时平行执行，它们中间可以用 &amp; 连接。</p>\n<p>写在 scripts 属性中的命令，也可以在 node_modules&#x2F;.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> site/main</span><br><span class=\"line\">browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js</span><br></pre></td></tr></table></figure>\n<p>假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;build-js&quot;</span>: <span class=\"string\">&quot;bin/build.sh&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"pre-和-post-脚本\"><a href=\"#pre-和-post-脚本\" class=\"headerlink\" title=\"pre- 和 post- 脚本\"></a>pre- 和 post- 脚本</h3><p>npm run 为每条命令提供了 pre- 和 post- 两个钩子（hook）。以 npm run lint 为例，执行这条命令之前，npm 会先查看有没有定义 prelint 和 postlint 两个钩子，如果有的话，就会先执行 npm run prelint，然后执行 npm run lint，最后执行 npm run postlint。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;myproject&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;devDependencies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;eslint&quot;</span>: <span class=\"string\">&quot;latest&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;karma&quot;</span>: <span class=\"string\">&quot;latest&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;lint&quot;</span>: <span class=\"string\">&quot;eslint --cache --ext .js --ext .jsx src&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;test&quot;</span>: <span class=\"string\">&quot;karma start --log-leve=error karma.config.js --single-run=true&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;pretest&quot;</span>: <span class=\"string\">&quot;npm run lint&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;posttest&quot;</span>: <span class=\"string\">&quot;echo &#x27;Finished running tests&#x27;&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码是一个 package.json 文件的例子。如果执行 npm test，会按下面的顺序执行相应的命令。</p>\n<ol>\n<li>pretest</li>\n<li>test</li>\n<li>posttest</li>\n</ol>\n<p>如果执行过程出错，就不会执行排在后面的脚本，即如果 prelint 脚本执行出错，就不会接着执行 lint 和 postlint 脚本。</p>\n<h3 id=\"npm-bin\"><a href=\"#npm-bin\" class=\"headerlink\" title=\"npm bin\"></a>npm bin</h3><p>npm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下执行</span></span><br><span class=\"line\">$ npm bin</span><br><span class=\"line\">./node_modules/.bin</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"创建全局链接\"><a href=\"#创建全局链接\" class=\"headerlink\" title=\"创建全局链接\"></a>创建全局链接</h1><p>npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 <code>npm install -g express</code> 安装了 express，这时在工程的目录下运行命令：<br><code>npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express</code><br>我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。<br>除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。</p>\n<h1 id=\"创建包\"><a href=\"#创建包\" class=\"headerlink\" title=\"创建包\"></a>创建包</h1><p>包是在模块基础上更深一步的抽象，Node.js 的包类似于 C&#x2F;C++ 的函数库或者 Java、.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。<br>Node.js 的包是一个目录，其中包含了一个 JSON 格式的包说明文件 package.json。严格符合 CommonJS 规范的包应该具备以下特征：<br>。package.json 必须在包的顶层目录下；<br>。二进制文件应该在 bin 目录下；<br>。JavaScript 代码应该在 lib 目录下；<br>。文档应该在 doc 目录下；<br>。单元测试应该在 test 目录下。</p>\n<p>Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。</p>\n<p>我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 package.json，我们可以创建更复杂，更完善，更符合规范的包用于发布。</p>\n<p>Node.js 在调用某个包时，会首先检查包中 packgage.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p>\n<p>package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段：<br><span id=\"inline-yellow\">name</span>: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。<br><span id=\"inline-blue\">description</span>: 包的简要说明。<br><span id=\"inline-green\">version</span>: 符合语义化版本识别规范的版本字符串。<br><span id=\"inline-red\">keywords</span>: 关键字数组，通常用于搜索。<br><span id=\"inline-purple\">maintainers</span>: 维护者数组，每个元素要包含 name 、email(可选)、web(可选)字段。<br><span id=\"inline-yellow\">contributors</span>: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。<br><span id=\"inline-blue\">bugs</span>: 提交 bug 的地址，可以是网址或者电子邮件地址。<br><span id=\"inline-green\">licenses</span>: 许可证数组，每个元素要包含 type（许可证的名称）和 url（链接到许可证文本的地址）字段。<br><span id=\"inline-red\">repositories</span>: 仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。<br><span id=\"inline-purple\">dependencies</span>: 包的依赖，一个关联数组，由包名称和版本号组成。</p>\n<h1 id=\"包的发布\"><a href=\"#包的发布\" class=\"headerlink\" title=\"包的发布\"></a>包的发布</h1><p>通过使用 npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个 index.js 作为包的接口,一个简单的包就制作完成了。<br>在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 npm adduser 根据提示完成账号的创建<br>完成后可以使用 npm whoami 检测是否已经取得了账号。<br>接下来,在 package.json 所在目录下运行 npm publish，稍等片刻就可以完成发布了，打开浏览器，访问 <a href=\"http://search.npmjs.org/\">http://search.npmjs.org/</a> 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install neveryumodule 命令来安装它。<br>如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段,然后重新使用 npm publish 命令就行了。<br>如果你对已发布的包不满意，可以使用 npm unpublish 命令来取消发布。</p>\n<p id=\"div-border-top-yellow\">*需要说明的是：json 文件不能有注释*\n</p>\n\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"http://javascript.ruanyifeng.com/nodejs/npm.html\">http://javascript.ruanyifeng.com/nodejs/npm.html</a></p>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><p>npm version  查看npm和node的版本<br>npm list –depth&#x3D;0 [-g]  查看[全局]安装的包<br>npm root [-g]  查看[全局的]包的安装路径</p>\n","categories":["前端"],"tags":["npm"]},{"title":"关于 JavaScript 中 this 的详细总结","url":"/2018/06/01/js-this/","content":"<p>在 JavaScript 中，函数中的 this 指向，很多同学总是理不清楚【这必然会带来一些问题】。确实，JavaScript 中，函数的 this 指向比较复杂多变。它和你调用的方式有关系，和 <strong>严格模式</strong> 或者 <strong>非严格模式</strong> 有关系，和你是否使用了箭头函数有关系，和你在使用函数时是否传入了 this 有关系，和你是否主动修改了调用对象有关系。</p>\n<ul>\n<li><p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值。<code>this</code> 不能再执行期间被赋值，并且在每次函数被调用时 <code>this</code> 的值也可能会不同。<code>ES5</code> 引入了 <code>bind</code> 方法来设置函数的 <code>this</code> 值，<a href=\"https://blog.csdn.net/csdn_yudong/article/details/78730844\">关于bind和call可以看我的文章</a>，而不用考虑函数如何被调用的，<code>ES2015</code> 引入了支持 <code>this</code> 词法解析的箭头函数（它在闭合的执行上下文内设置 <code>this</code> 的值）。</p>\n</li>\n<li><p>与其他语言相比，<strong>函数的 <code>this</code> 关键字</strong>在 <code>JavaScript</code> 中的表现略有不同，此外，在 严格模式 和 非严格模式之间也会有一些差别。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"全局上下文\"><a href=\"#全局上下文\" class=\"headerlink\" title=\"全局上下文\"></a>全局上下文</h2><p>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）<code>this</code> 都指代全局对象。【在全局执行上下文中 <code>this</code> 都是全局对象 <code>window</code>】（浏览器环境）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);    <span class=\"comment\">// window</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">a</span>);  <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);    <span class=\"comment\">// window</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">b</span>);  <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数上下文\"><a href=\"#函数上下文\" class=\"headerlink\" title=\"函数上下文\"></a>函数上下文</h2><p>在函数内部，<code>this</code> 的值取决于函数被调用的方式。【取决于被调用的方式】</p>\n<h3 id=\"简单调用\"><a href=\"#简单调用\" class=\"headerlink\" title=\"简单调用\"></a>简单调用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f1</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在浏览器中</span></span><br><span class=\"line\"><span class=\"title function_\">f1</span>() === <span class=\"variable language_\">window</span>;  <span class=\"comment\">// 在浏览器中，全局对象是widnow</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 Node 中</span></span><br><span class=\"line\"><span class=\"title function_\">f1</span>() === <span class=\"variable language_\">global</span>;</span><br></pre></td></tr></table></figure>\n\n<p>【在严格模式下，<code>this</code> 将保持他进入执行上下文时的值】</p>\n<p>在严格模式下，<code>this</code> 将保持他进入执行上下文时的值，所以下面的 <code>this</code> 将会默认为 <code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f2</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;use strict&quot;</span>; <span class=\"comment\">// 这里是严格模式</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f2</span>() === <span class=\"literal\">undefined</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，在严格模式下，如果 <code>this</code> 没有被执行上下文（execution context）定义，那它将保持为 <code>undefined</code>。</p>\n<p>因为 <code>f2()</code> 是被直接调用的，而不是作为对象的属性或方法调用的（如<code>window.f2()</code>）。有一些浏览器最初在支持严格模式时没有正确实现这个功能，于是它们错误的返回了 <code>window</code> 对象。</p>\n<p>但是，如果用 <code>window</code> 来调用的话，<code>this</code> 就是 <code>window</code> 了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f2</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;use strict&quot;</span>; <span class=\"comment\">// 这里是严格模式</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"title function_\">f2</span>())  <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要想把 <code>this</code> 的值从一个上下文传到另一个，就要用 <code>call</code> 或者 <code>apply</code> 方法。</p>\n<p>当一个函数在其主体中使用 <code>this</code> 关键字时，可以通过使用函数继承自 <code>Function.prototype</code> 的 <code>call</code> 或 <code>apply</code> 方法将 <code>this</code> 值绑定到调用中的特定对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">c, d</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> + c + d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数是作为‘this’使用的对象</span></span><br><span class=\"line\"><span class=\"comment\">// 后续参数作为参数传递给函数调用</span></span><br><span class=\"line\">add.<span class=\"title function_\">call</span>(o, <span class=\"number\">5</span>, <span class=\"number\">7</span>); <span class=\"comment\">// 1 + 3 + 5 + 7 = 16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数也是作为‘this’使用的对象</span></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数是一个数组，数组里的元素用作函数调用中的参数</span></span><br><span class=\"line\">add.<span class=\"title function_\">apply</span>(o, [<span class=\"number\">10</span>, <span class=\"number\">20</span>]); <span class=\"comment\">// 1 + 3 + 10 + 20 = 34</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 <code>call</code> 和 <code>apply</code> 函数的时候要注意，如果传递给 <code>this</code> 的值不是一个对象，<code>JavaScript</code> 会尝试使用内部 <code>ToObject</code> 操作将其转换为对象。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">因此，如果传递的值是一个原始值比如 <span class=\"number\">7</span> 或 <span class=\"string\">&#x27;foo&#x27;</span>，那么就会使用相关构造函数将它转换为对象，所以原始值 <span class=\"number\">7</span> 会被转为对象，像 </span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>(<span class=\"number\">7</span>) 这样，而字符串 <span class=\"string\">&#x27;foo&#x27;</span> 转化成 <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&#x27;foo&#x27;</span>) 这样。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind 方法\"></a>bind 方法</h2><p><code>ECMAScript 5</code> 引入了 <code>Function.prototype.bind</code>。调用 <code>f.bind(someObject)</code> 会 <strong>创建</strong>一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code> 将永久地被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的。</p>\n<p>【<code>this</code> 将永久的被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的】</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f.<span class=\"title function_\">bind</span>(&#123;<span class=\"attr\">a</span>:<span class=\"string\">&quot;azerty&quot;</span>&#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">g</span>()); <span class=\"comment\">// azerty</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> h = g.<span class=\"title function_\">bind</span>(&#123;<span class=\"attr\">a</span>:<span class=\"string\">&#x27;yoo&#x27;</span>&#125;); <span class=\"comment\">// bind只生效一次！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">h</span>()); <span class=\"comment\">// azerty</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">a</span>:<span class=\"number\">37</span>, <span class=\"attr\">f</span>:f, <span class=\"attr\">g</span>:g, <span class=\"attr\">h</span>:h&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o.<span class=\"title function_\">f</span>(), o.<span class=\"title function_\">g</span>(), o.<span class=\"title function_\">h</span>()); <span class=\"comment\">// 37, azerty, azerty</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>在箭头函数中，<code>this</code> 与封闭词法上下文的 <code>this</code> 保持一致。在全局代码中，它将被设置为全局对象。【封闭词法上下文 是什么意思，你知道吗？】</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = (<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接着上面的代码</span></span><br><span class=\"line\"><span class=\"comment\">// 作为对象的一个方法调用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">foo</span>: foo&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">foo</span>() === <span class=\"variable language_\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试使用call来设定this</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo.<span class=\"title function_\">call</span>(obj) === <span class=\"variable language_\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试使用bind来设定this</span></span><br><span class=\"line\">foo = foo.<span class=\"title function_\">bind</span>(obj);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">foo</span>() === <span class=\"variable language_\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>【无论如何，<code>foo</code> 的 <code>this</code> 被设置为<strong>他被创建时的上下文</strong>（在上面的例子中，就是全局对象）】<br>这同样适用于在其他函数内创建的箭头函数：这些箭头函数的 <code>this</code> 被设置为封闭的词法上下文的。</p>\n<h2 id=\"作为对象的方法\"><a href=\"#作为对象的方法\" class=\"headerlink\" title=\"作为对象的方法\"></a>作为对象的方法</h2><blockquote>\n<p>当函数作为对象里的方法被调用时，它们的 <code>this</code> 是调用该函数的对象</p>\n</blockquote>\n<p><code>this</code> 的绑定只受最靠近的成员引用的影响。在下面的例子中，我们把一个方法 <code>g</code> 当做对象 <code>o.b</code> 的函数调用。在这次执行期间，函数中的 <code>this</code> 将指向 <code>o.b</code> 。事实证明，这与他是对象 <code>o</code> 的成员没有多大关系，最靠近的引用才是最重要的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">o.<span class=\"property\">b</span> = &#123; <span class=\"attr\">g</span>: independent, <span class=\"attr\">prop</span>: <span class=\"number\">42</span> &#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o.<span class=\"property\">b</span>.<span class=\"title function_\">g</span>())</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"原型链中的-this\"><a href=\"#原型链中的-this\" class=\"headerlink\" title=\"原型链中的 this\"></a>原型链中的 <code>this</code></h2><p>对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 <code>this</code> 指向的是调用这个方法的对象，就像该方法在对象上一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  <span class=\"attr\">f</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">b</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(o);</span><br><span class=\"line\">p.<span class=\"property\">a</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">p.<span class=\"property\">b</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(p.<span class=\"title function_\">f</span>()); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，对象 <code>p</code> 没有属于它自己的 <code>f</code> 属性，它的 <code>f</code> 属性继承自它的原型。虽然在对 <code>f</code> 的查找过程中，最终是在 <code>o</code> 中找到 <code>f</code> 属性的，这并没有关系；查找过程首先从 <code>p.f</code> 的引用开始，所以函数中的 <code>this</code> 指向 <code>p</code>。也就是说，因为 <code>f</code> 是作为 <code>p</code> 的方法调用的，所以它的 <code>this</code> 指向了 <code>p</code> 。这是 <code>JavaScript</code> 的原型继承中的一个有趣的特性。</p>\n<h2 id=\"作为构造函数\"><a href=\"#作为构造函数\" class=\"headerlink\" title=\"作为构造函数\"></a>作为构造函数</h2><p>当一个函数用作构造函数时（适用 <code>new</code> 关键字），它的 <code>this</code> 被绑定到正在构造的新对象。</p>\n<p>虽然构造器返回的默认值是 <code>this</code> 所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回 <code>this</code> 对象）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 构造函数这样工作:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * function MyConstructor()&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *   // 函数实体写在这里</span></span><br><span class=\"line\"><span class=\"comment\"> *   // 根据需要在this上创建属性，然后赋值给它们，比如：</span></span><br><span class=\"line\"><span class=\"comment\"> *   this.fum = &quot;nom&quot;;</span></span><br><span class=\"line\"><span class=\"comment\"> *   // 等等...</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   // 如果函数具有返回对象的return语句，</span></span><br><span class=\"line\"><span class=\"comment\"> *   // 则该对象将是 new 表达式的结果。 </span></span><br><span class=\"line\"><span class=\"comment\"> *   // 否则，表达式的结果是当前绑定到 this 的对象。</span></span><br><span class=\"line\"><span class=\"comment\"> *   //（即通常看到的常见情况）。</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">C</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> = <span class=\"number\">37</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"title function_\">C</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o.<span class=\"property\">a</span>); <span class=\"comment\">// 37</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">C2</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> = <span class=\"number\">37</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;<span class=\"attr\">a</span>:<span class=\"number\">38</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">o = <span class=\"keyword\">new</span> <span class=\"title function_\">C2</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o.<span class=\"property\">a</span>); <span class=\"comment\">// 38</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在刚刚的例子中（C2），因为在调用构造函数的过程中，手动的设置了返回对象，与 <code>this</code> 绑定的默认对象被丢弃了。（这基本上使得语句 <code>this.a = 37;</code> 成了“僵尸”代码，实际上并不是真正的“僵尸”，这条语句执行了，但是对于外部没有任何影响，因此完全可以忽略它）。</p>\n<h2 id=\"作为一个-DOM-事件处理函数\"><a href=\"#作为一个-DOM-事件处理函数\" class=\"headerlink\" title=\"作为一个 DOM 事件处理函数\"></a>作为一个 DOM 事件处理函数</h2><blockquote>\n<p>当函数被用作事件处理函数时，它的 <code>this</code> 指向触发事件的元素（一些浏览器在使用非 <code>addEventListener</code> 的函数动态添加监听函数时不遵守这个约定）。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被调用时，将关联的元素变成蓝色</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bluify</span>(<span class=\"params\">e</span>)&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span> === e.<span class=\"property\">currentTarget</span>); <span class=\"comment\">// 总是 true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 当 currentTarget 和 target 是同一个对象时为 true</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span> === e.<span class=\"property\">target</span>);        </span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = <span class=\"string\">&#x27;#A5D9F3&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取文档中的所有元素的列表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> elements = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;*&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span> ; i&lt;elements.<span class=\"property\">length</span> ; i++)&#123;</span><br><span class=\"line\">  elements[i].<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, bluify, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"作为一个内联事件处理函数\"><a href=\"#作为一个内联事件处理函数\" class=\"headerlink\" title=\"作为一个内联事件处理函数\"></a>作为一个内联事件处理函数</h2><blockquote>\n<p>当代码被内联 <code>on-event</code> 处理函数 调用时，它的 <code>this</code> 指向监听器所在的 <code>DOM</code> 元素</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(this.tagName.toLowerCase());&quot;</span>&gt;</span></span><br><span class=\"line\">  Show this</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的 <code>alert</code> 会显示 <code>button</code> 。注意只有外层代码中的 <code>this</code> 是这样设置的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert((function()&#123;return this&#125;)());&quot;</span>&gt;</span></span><br><span class=\"line\">  Show inner this</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，没有设置内部函数的 <code>this</code>，所以它指向 <code>global/window</code> 对象（即非严格模式下调用的函数未设置 <code>this</code> 时指向的默认对象）。</p>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"Sass 教程","url":"/2016/10/23/sass/","content":"<p><span id=\"inline-blue\" style=\"font-size:100%;border-radius:3px;\">Sass</span>： (Syntactically Awesome StyleSheets)</p>\n<h1 id=\"sass简介\"><a href=\"#sass简介\" class=\"headerlink\" title=\"sass简介\"></a>sass简介</h1><p>来自于官网的简介：<br>Sass is the most mature, stable, and powerful professional grade CSS extension language in the world.<br><font color=red> Sass 是世界上最成熟的，稳定的，功能强大的专业级 CSS 扩展语言。</font></p>\n<span id=\"more\"></span>\n\n<h1 id=\"sass-安装\"><a href=\"#sass-安装\" class=\"headerlink\" title=\"sass 安装\"></a>sass 安装</h1><p>因为 sass 依赖 ruby 环境，所以装 sass 之前先确认安装了 ruby .<br>在安装的时候，请勾选 Add Ruby executables to your PATH 这个选项，添加环境变量，不然以后使用编译软件的时候会提示找不到 ruby 环境.<br><img src=\"http://i1.piimg.com/567571/3a876fb3bb575d25.png\"></p>\n<p>安装完 ruby 之后，在开始菜单中，打开我们的命令行，输入<br><code>ruby -v</code></p>\n<p><img src=\"http://i1.piimg.com/567571/e5795e583371ce6d.png\"><br>那么我们的 ruby 就安装成功了。</p>\n<p>然后直接在命令行中输入<br><code>gem install sass</code><br>按回车键确认，等待一段时间就会提示你 sass 安装成功。</p>\n<p>如果要安装 beta 版本的，可以在命令行中输入<br><code>gem install sass --pre</code></p>\n<p>最近因为墙的比较厉害，如果你没有安装成功，那么请参考下面的淘宝的 RubyGems 镜像安装 sass ，如果成功则忽略。<br>由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过 gem sources 命令来配置源，先移除默认的 <a href=\"https://rubygems.org/\">https://rubygems.org</a> 源，然后添加淘宝的源 <code>https://ruby.taobao.org/</code> ，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入 sass 安装命令 gem install sass 了.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gem sources --remove https://rubygems.org/</span><br><span class=\"line\">gem sources -a https://ruby.taobao.org/</span><br><span class=\"line\">gem sources -l</span><br></pre></td></tr></table></figure>\n<p>如果输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">*** CURRENT SOURCES ***</span><br><span class=\"line\">https://ruby.taobao.org</span><br></pre></td></tr></table></figure>\n<p>则表示镜像替换成功，下一步</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gem install sass</span><br></pre></td></tr></table></figure>\n\n<p>按回车键确认，等待一段时间就会提示你 sass 安装成功。</p>\n<p>如果你熟悉 git 命令的话，你还可以从 sass 的 Git repository 来安装，git 的命令行为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone git://github.com/nex3/sass.git</span><br><span class=\"line\">cd sass</span><br><span class=\"line\">rake install</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"如何升级-sass-版本\"><a href=\"#如何升级-sass-版本\" class=\"headerlink\" title=\"如何升级 sass 版本\"></a>如何升级 sass 版本</h1><p>我们可以使用命令 <code>gem update sass</code> 来升级我们的 sass 版本。</p>\n<p>如果想要安装sass的某一特定版本，命令行为<br><code>gem install sass --version=3.3.0</code></p>\n<p>如果想要删除sass的某一特定版本，命令行为<br><code>gem uninstall sass --version=3.3.0</code></p>\n<p>卸载sass,命令行为<br><code>gem uninstall sass</code></p>\n<p>查看sass版本的命令行为<br><code>sass -v</code></p>\n<p>查看ruby安装的所有程序包，命令语句为 <code>gem list</code> 。</p>\n<h1 id=\"sass-命令\"><a href=\"#sass-命令\" class=\"headerlink\" title=\"sass 命令\"></a>sass 命令</h1><p>安装成功 sass 以后，我们来写个 demo 测试一下：<br>创建一个 <code>style.scss</code> 文件：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$fontSize</span>: <span class=\"number\">14px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"variable\">$fontSize</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单文件转换</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sass style.scss style.css</span><br></pre></td></tr></table></figure>\n\n<p>单文件监听</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sass --watch style.scss:style.css</span><br></pre></td></tr></table></figure>\n\n<p>文件夹监听</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sass --watch sassFileDirectory:cssFileDirectory</span><br></pre></td></tr></table></figure>\n\n<p>css 文件转成 sass&#x2F;scss 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sass-convert style.css style.sass</span><br><span class=\"line\">sass-convert style.css style.scss</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"sass-命令配置选项\"><a href=\"#sass-命令配置选项\" class=\"headerlink\" title=\"sass 命令配置选项\"></a>sass 命令配置选项</h2><p>运行命令行帮助文档，可以获得所有的配置选项</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sass -h</span><br></pre></td></tr></table></figure>\n\n<p>配置选项 <code>--style</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sass style.scss:style.css --style compact</span><br></pre></td></tr></table></figure>\n<p><code>--style</code> 表示解析后的 css 是什么格式，有四种取值分别为：expanded ，nested ，compact ，compressed 。</p>\n<p>配置选项 <code>--sourcemap</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sass style.scss:style.css --sourcemap</span><br></pre></td></tr></table></figure>\n<p><code>--sourcemap</code> 表示开启 sourcemap 调试。开启 sourcemap 调试后，会生成一个后缀名为 .css.map 文件。</p>\n<p>配置选项 <code>--debug-info</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sass style.scss:style.css --debug-info</span><br></pre></td></tr></table></figure>\n<p><code>--debug-info</code> 表示开启 debug 信息，升级到 3.3.0 之后因为 sourcemap 更高级，这个 debug-info 就不太用了。</p>\n<h1 id=\"sass语法\"><a href=\"#sass语法\" class=\"headerlink\" title=\"sass语法\"></a>sass语法</h1><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>在介绍 sass 语法之前，最有必要的是先来了解一下 sass 中的注释。<br>sass 有两种注释方式，一种是标准的 css 注释方式 <code>/* */</code>，另一种则是 <code>//</code> 双斜杆形式的单行注释，不过这种单行注释不会被转译出来，也就是说 <code>//</code> 这种注释不会转译到编译后的 css 文件中。</p>\n<p>需要说明的是：如果你的注释中有中文的话，请务必在 scss 文件开头加上：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@charset</span> <span class=\"string\">&quot;UTF-8&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有这个的话，会报错。</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>sass 的变量必须是 $ 开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(：)分隔开（就像 CSS 属性设置一样），如果值后面加上 !default 则表示默认值。<br>普通变量<br>定义之后可以在全局范围内使用。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$fontSize</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"variable\">$fontSize</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认变量\"><a href=\"#默认变量\" class=\"headerlink\" title=\"默认变量\"></a>默认变量</h3><p>sass 的默认变量仅需要在值后面加上 <code>!default</code> 即可。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$baseLineHeight</span>: <span class=\"number\">1.5</span> !default;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"variable\">$baseLineHeight</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$baseLineHeight</span>: <span class=\"number\">1.5</span> !default;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"variable\">$baseLineHeight</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable\">$baseLineHeight</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"variable\">$baseLineHeight</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个相当于给 $baseLineHeight 设置了一个默认值，如果你想重新设置的话，可以再写一个 $baseLineHeight 的属性值来覆盖它。</p>\n<h3 id=\"特殊变量\"><a href=\"#特殊变量\" class=\"headerlink\" title=\"特殊变量\"></a>特殊变量</h3><p>一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以 <code>#&#123;$variables&#125;</code> 形式使用。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$borderDirection</span>: top !default;</span><br><span class=\"line\"><span class=\"variable\">$baseFontSize</span>: <span class=\"number\">12px</span> !default;</span><br><span class=\"line\"><span class=\"variable\">$baseLineHeight</span>: <span class=\"number\">1.5</span> !default;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//应用于 class 和属性</span></span><br><span class=\"line\"><span class=\"selector-class\">.border-</span>#&#123;<span class=\"variable\">$borderDirection</span>&#125; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>-#&#123;<span class=\"variable\">$borderDirection</span>&#125;: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//应用于复杂的属性值</span></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>:#&#123;<span class=\"variable\">$baseFontSize</span>&#125;/#&#123;<span class=\"variable\">$baseLineHeight</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>这个地方我们如果不用 <code>#&#123;$variables&#125;</code> 形式的话，那么结果中 body 的样式就是：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">8px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这显然不是我们想要的。</p>\n<h3 id=\"多值变量\"><a href=\"#多值变量\" class=\"headerlink\" title=\"多值变量\"></a>多值变量</h3><p>多值变量分为 list 类型和 map 类型，简单来说 list 类型有点像 js 中的数组，而 map 类型有点像 js 中的对象。</p>\n<h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><p>list 数据可通过空格，逗号或小括号分隔多个值，可用 nth($var,$index) 取值。关于 list 数据操作还有很多其他函数如 <code>length($list)</code> ， <code>join($list,$list2,[$separator])</code> ， <code>append($list,$value,[$separator])</code> 等。</p>\n<p>定义</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一维数组</span></span><br><span class=\"line\"><span class=\"variable\">$px</span>: <span class=\"number\">5px</span> <span class=\"number\">10px</span> <span class=\"number\">20px</span> <span class=\"number\">30px</span>;</span><br><span class=\"line\"><span class=\"comment\">//二维数组</span></span><br><span class=\"line\"><span class=\"variable\">$px</span>: <span class=\"number\">5px</span> <span class=\"number\">10px</span>, <span class=\"number\">20px</span> <span class=\"number\">30px</span>;</span><br><span class=\"line\"><span class=\"variable\">$px</span>: (<span class=\"number\">5px</span> <span class=\"number\">10px</span>) (<span class=\"number\">20px</span> <span class=\"number\">30px</span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$linkColor</span>: <span class=\"number\">#08c</span> <span class=\"number\">#333</span> !default;<span class=\"comment\">//第一个值为默认值，第二个鼠标滑过值</span></span><br><span class=\"line\"><span class=\"selector-tag\">a</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:nth(<span class=\"variable\">$linkColor</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:hover</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:nth(<span class=\"variable\">$linkColor</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:<span class=\"number\">#08c</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:<span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>map 数据以 key和 value 成对出现，其中 value 又可以是 list 。格式为： <code>$map:(key1: value1,key2:value2,key3:value3);</code> 。可通过 <code>map-get($map,$key)</code> 取值。关于map数据还有很多其他函数如 <code>map-merge($map1,$map2)</code> ， <code>map-keys($map)</code> ， <code>map-values($map)</code> 等。</p>\n<p>定义</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$heading</span>: (h1: <span class=\"number\">2em</span>, h2: <span class=\"number\">1.5em</span>, h3: <span class=\"number\">1.2em</span>);</span><br></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$headings</span>: (h1: <span class=\"number\">2em</span>, h2: <span class=\"number\">1.5em</span>, h3: <span class=\"number\">1.2em</span>);</span><br><span class=\"line\"><span class=\"keyword\">@each</span> <span class=\"variable\">$header</span>, <span class=\"variable\">$size</span> in <span class=\"variable\">$headings</span> &#123;</span><br><span class=\"line\">  #&#123;<span class=\"variable\">$header</span>&#125; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"variable\">$size</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">2em</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5em</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2em</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><p>在变量值后面加上 !global 即为全局变量。<br>在选择器中声明的变量会覆盖外面全局声明的变量。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$fontSize</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"variable\">$fontSize</span>: <span class=\"number\">14px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"variable\">$fontSize</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"variable\">$fontSize</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启用global之后的机制</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$fontSize</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"variable\">$fontSize</span>: <span class=\"number\">14px</span> !global;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"variable\">$fontSize</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"variable\">$fontSize</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与上面的机制对比就会发现默认在选择器里面的变量为局部变量，而只有设置了 !global 之后才会成为全局变量。</p>\n<h2 id=\"嵌套-Nesting\"><a href=\"#嵌套-Nesting\" class=\"headerlink\" title=\"嵌套(Nesting)\"></a>嵌套(Nesting)</h2><p>sass 的嵌套包括两种：一种是选择器的嵌套；另一种是属性的嵌套。</p>\n<h3 id=\"选择器嵌套\"><a href=\"#选择器嵌套\" class=\"headerlink\" title=\"选择器嵌套\"></a>选择器嵌套</h3><p>所谓选择器嵌套指的是在一个选择器中嵌套另一个选择器来实现继承，从而增强了 sass 文件的结构性和可读性。<br>在选择器嵌套中，可以使用 <code>&amp;</code> 表示父元素选择器</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#top_nav</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-transform</span>: capitalize;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    &amp;<span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: <span class=\"number\">#ddd</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性嵌套\"><a href=\"#属性嵌套\" class=\"headerlink\" title=\"属性嵌套\"></a>属性嵌套</h3><p>所谓属性嵌套指的是有些属性拥有同一个开始单词，如border-width，border-color都是以border开头。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.fakeshadow</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: &#123;</span><br><span class=\"line\">    style: solid;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">4px</span>;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: <span class=\"number\">#888</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然这个只是属性嵌套的一个例子，在实际中这样来写 <code>border</code> 的样式或许有些复杂了，但在属性嵌套在别的地方肯定用得到。</p>\n<h2 id=\"at-root\"><a href=\"#at-root\" class=\"headerlink\" title=\"@at-root\"></a>@at-root</h2><p>sass3.3.0 中新增的功能，用来跳出选择器嵌套的。默认所有的嵌套，继承所有上级选择器，但有了这个就可以跳出所有上级选择器。</p>\n<h3 id=\"普通跳出嵌套\"><a href=\"#普通跳出嵌套\" class=\"headerlink\" title=\"普通跳出嵌套\"></a>普通跳出嵌套</h3><figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*没有跳出*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.parent-1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>;</span><br><span class=\"line\">  <span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*单个选择器跳出*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.parent-2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>;</span><br><span class=\"line\">  <span class=\"keyword\">@at-root</span> .child &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*多个选择器跳出*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.parent-3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</span><br><span class=\"line\">  <span class=\"keyword\">@at-root</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-class\">.child1</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-class\">.child2</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>默认 <code>@at-root</code> 只会跳出选择器嵌套，而不能跳出 <code>@media</code> 或 <code>@support</code> ，如果要跳出这两种，则需要使用 <code>@at-root(without:media)</code> ，<code>@at-root(without:support)</code> 。这个语法的关键词有四个： <code>all</code> （表示所有），<code>true</code>（表示常规CSS）， <code>media</code>（表示media）， ‘support’（表示support，因为 <code>@support</code> 目前还无法广泛使用）。我们默认的 <code>@at-root</code> 其实就是 <code>@at-root(without:rule)</code> 。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> print &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.parent1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">@at-root</span> .child1 &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">200px</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//跳出media嵌套，父级有效</span></span><br><span class=\"line\"><span class=\"keyword\">@media</span> print &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.parent2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>;</span><br><span class=\"line\">    <span class=\"keyword\">@at-root</span> (<span class=\"attribute\">without</span>:media) &#123;</span><br><span class=\"line\">      <span class=\"selector-class\">.child2</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//跳出media和父级</span></span><br><span class=\"line\"><span class=\"keyword\">@media</span> print &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.parent3</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>;</span><br><span class=\"line\">    <span class=\"keyword\">@at-root</span> (<span class=\"attribute\">without</span>:all) &#123;</span><br><span class=\"line\">      <span class=\"selector-class\">.child3</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@at-root</code> 与 <code>&amp;</code> 配合使用</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@at-root</span> .parent &amp; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>应用于<code>@keyframe</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: motion <span class=\"number\">3s</span> infinite;</span><br><span class=\"line\">  <span class=\"keyword\">@at-root</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@keyframes</span> motion &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">    ...   </span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: motion <span class=\"number\">3s</span> infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> motion &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我认为 <code>@at-root</code> 应用于 <code>@keyframe</code> 或许是 <code>@at-root</code> 最好的实践。<br>跳出嵌套，我们为什么要用 <code>@at-root</code> 来实现呢？我们完全可以在写样式的时候，不使用嵌套的写法。<br>但是 <code>@keyframe</code> 就不一样了，这个动画应用于当前选择器，所以把动画样式写入这个选择器的结构里，方便修改与查看。<br>相比于之前在 css 中使用 @keyframe 来定义动画，然后在元素中调用，如果一个文件中 @keyframe 比较多的话，在我们想要调用动画的时候，动画与元素之间的关联性比较差。</p>\n<h2 id=\"混合-mixin\"><a href=\"#混合-mixin\" class=\"headerlink\" title=\"混合(mixin)\"></a>混合(mixin)</h2><p>sass 中使用 <code>@mixin</code> 声明混合，可以传递参数，参数名以 $ 符号开始，多个参数以逗号分开，也可以给参数设置默认值，声明的 @mixin 通过 @include 来调用。</p>\n<h3 id=\"无参数mixin\"><a href=\"#无参数mixin\" class=\"headerlink\" title=\"无参数mixin\"></a>无参数mixin</h3><figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@mixin</span> center-block &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: &#123;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: auto;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: auto;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> center-block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>:auto;</span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"有参数mixin\"><a href=\"#有参数mixin\" class=\"headerlink\" title=\"有参数mixin\"></a>有参数mixin</h3><figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@mixin</span> opacity(<span class=\"variable\">$opacity</span>: <span class=\"number\">50</span>) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"variable\">$opacity</span> / <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"attribute\">filter</span>: alpha(opacity=<span class=\"variable\">$opacity</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.opacity</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> opacity; <span class=\"comment\">//参数使用默认值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.opacity-80</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> opacity(<span class=\"number\">80</span>); <span class=\"comment\">//传递参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个参数mixin\"><a href=\"#多个参数mixin\" class=\"headerlink\" title=\"多个参数mixin\"></a>多个参数mixin</h3><p>调用时可直接传入值，如 <code>@include</code> 传入参数的个数小于 <code>@mixin</code> 定义参数的个数，则按照顺序表示，后面不足的使用默认值，如不足的没有默认值则报错。除此之外还可以选择性的传入参数，使用参数名与值同时传入。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@mixin</span> horizontal-line(<span class=\"variable\">$border</span>:<span class=\"number\">1px</span> dashed <span class=\"number\">#ccc</span>,<span class=\"variable\">$padding</span>:<span class=\"number\">10px</span>) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"variable\">$border</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-top</span>: <span class=\"variable\">$padding</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"variable\">$padding</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.imgtext-h</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> horizontal-line(<span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.imgtext-h-product</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> horizontal-line(<span class=\"variable\">$padding</span>:<span class=\"number\">15px</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.imgtext-h</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#cccccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding-top</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.imgtext-h--product</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> dashed <span class=\"number\">#cccccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding-top</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多组值参数mixin\"><a href=\"#多组值参数mixin\" class=\"headerlink\" title=\"多组值参数mixin\"></a>多组值参数mixin</h3><p>如果一个参数可以有多组值，如 <code>box-shadow</code> 、<code>transition</code> 等，那么参数则需要在变量后加三个点表示，如 <code>$variables...</code> 。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//box-shadow可以有多组值，所以在变量参数后面添加...</span></span><br><span class=\"line\"><span class=\"keyword\">@mixin</span> box-shadow(<span class=\"variable\">$shadow</span>...) &#123;</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">box-shadow</span>: <span class=\"variable\">$shadow</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"variable\">$shadow</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> box-shadow (<span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">2px</span> rgba(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,.<span class=\"number\">3</span>),<span class=\"number\">0</span> <span class=\"number\">3px</span> <span class=\"number\">3px</span> rgba(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,.<span class=\"number\">3</span>),<span class=\"number\">0</span> <span class=\"number\">4px</span> <span class=\"number\">4px</span> rgba(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,.<span class=\"number\">3</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"content\"><a href=\"#content\" class=\"headerlink\" title=\"@content\"></a>@content</h2><p>@content 可以用来解决 css3 的 @media 等带来的问题。它可以使 @mixin 接受一整块样式，接受的样式从 @content 开始。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@mixin</span> max-screen(<span class=\"variable\">$res</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@media</span> <span class=\"keyword\">only</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width</span>:<span class=\"variable\">$res</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@content</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@include</span> max-screen(<span class=\"number\">480px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PS：@mixin 通过 @include 调用后解析出来的样式是以拷贝形式存在的，而下面的继承则是以联合声明的方式存在的，所以从 3.2.0 版本以后，建议传递参数的用 @mixin ，而非传递参数的使用下面的继承 % 。</p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>sass 中，选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词 @extend ，后面紧跟需要继承的选择器。</p>\n<p>使用</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">4px</span> solid <span class=\"number\">#ff9aa9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.speaker</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> h1;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h1</span>,<span class=\"selector-class\">.speaker</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">4px</span> solid <span class=\"number\">#ff9aa9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.speaker</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，选择器继承生成的样式不是拷贝的形式，而是以联合声明的方式存在的。</p>\n<h3 id=\"继承的工作细节\"><a href=\"#继承的工作细节\" class=\"headerlink\" title=\"继承的工作细节\"></a>继承的工作细节</h3><p>关于 @extend 有两个要点你应该知道：</p>\n<p>1、跟混合器相比，继承生成的 css 代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的 css 体积更小。如果你非常关心你站点的速度，请牢记这一点。<br>举个例子，使用混合器的时候：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@mixin</span> border-colors &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.demo1</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> border-colors;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.demo2</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@include</span> border-colors; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它生成的 <code>css</code> 如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.demo2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用继承的时候：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.demo2</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> .demo1; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它生成的 <code>css</code> 如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo1</span>, <span class=\"selector-class\">.demo2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的 css 体积更小。</p>\n<p>2、继承遵从 css 层叠的规则。当两个不同的 css 规则应用到同一个 html 元素上时，并且这两个不同的 css 规则对同一属性的修饰存在不同的值， css 层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。</p>\n<p>混合器本身不会引起 css 层叠的问题，因为混合器把样式直接放到了 css 规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。通常来说这并不会引起什么问题，但是知道这点总没有坏处。</p>\n<h3 id=\"使用继承的最佳实践\"><a href=\"#使用继承的最佳实践\" class=\"headerlink\" title=\"使用继承的最佳实践\"></a>使用继承的最佳实践</h3><p>通常使用继承会让你的 css 美观、整洁。因为继承只会在生成 css 时复制选择器，而不会复制大段的 css 属性。但是如果你不小心，可能会让生成的 css 中包含大量的选择器复制。<br>避免这种情况出现的最好方法就是不要在 css 规则中使用后代选择器（比如 .foo .bar）去继承 css 规则。如果你这么做，同时被继承的 css 规则有通过后代选择器修饰的样式，生成 css 中的选择器的数量很快就会失控。<br>例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.bip</span> <span class=\"selector-class\">.baz</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.foo</span> <span class=\"selector-class\">.bar</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> .baz;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成的css如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.bip</span> <span class=\"selector-class\">.baz</span>, <span class=\"selector-class\">.bip</span> <span class=\"selector-class\">.foo</span> <span class=\"selector-class\">.bar</span>, <span class=\"selector-class\">.foo</span> <span class=\"selector-class\">.bip</span> <span class=\"selector-class\">.bar</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以如果允许，尽可能避免这种用法。<br>** 值得一提的是，只要你想，你完全可以放心地继承有后代选择器修饰规则的选择器，不管后代选择器多长，但有一个前提就是，不要用后代选择器去继承。 **</p>\n<h2 id=\"占位选择器\"><a href=\"#占位选择器\" class=\"headerlink\" title=\"占位选择器 %\"></a>占位选择器 %</h2><p>从 sass 3.2.0 以后就可以定义占位选择器 % 。这种选择器的优势在于：如果不调用则不会有任何多余的css文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中不管是否使用了 @extend 去继承相应的样式，都会解析出来所有的样式。占位选择器以 % 标识定义，通过 @extend 调用。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\">%ir &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: transparent;</span><br><span class=\"line\">  <span class=\"attribute\">text-shadow</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable\">$lte7</span>:true !default;</span><br><span class=\"line\">%clearfix &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@if</span> <span class=\"variable\">$lte7</span> &#123;</span><br><span class=\"line\">    *zoom: <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:before</span>,&amp;<span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">0</span>/<span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#header</span> &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@extend</span> %ir;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.ir</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@extend</span> %ir;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码，定义了两个占位选择器 <code>%ir</code> 和 <code>%clearfix</code> ，其中 <code>%clearfix</code> 这个没有调用，所以解析出来的css样式也就没有clearfix部分。占位选择器的出现，使css文件更加简练可控，没有多余。所以可以用其定义一些基础的样式文件，然后根据需要调用产生相应的css。<br>ps:在 @media 中暂时不能 @extend ， @media 外的代码片段，以后将会可以。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>sass 定义了很多函数可供使用，当然你也可以自己定义函数，以 @function 开始。sass 的官方函数链接为：<a href=\"http://sass-lang.com/documentation/Sass/Script/Functions.html\">sass function</a> ，实际项目中我们使用最多的应该是颜色函数，而颜色函数中又以 lighten 减淡和 darken 加深使用最多，其调用方法为 <code>lighten($color,$amout)</code> 和 <code>darken($color,$amount)</code> ，它们的第一个参数都是颜色值，第二个参数都是百分比。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$baseFontSize</span>: <span class=\"number\">10px</span> !default;</span><br><span class=\"line\"><span class=\"variable\">$gray</span>: <span class=\"number\">#ccc</span> !default;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@function</span> pxToRem(<span class=\"variable\">$px</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@return</span> <span class=\"variable\">$px</span> / <span class=\"variable\">$baseFontSize</span> * <span class=\"number\">1rem</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"variable\">$baseFontSize</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: lighten(<span class=\"variable\">$gray</span>,<span class=\"number\">10%</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.test</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: pxToRem(<span class=\"number\">16px</span>);</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: darken(<span class=\"variable\">$gray</span>,<span class=\"number\">10%</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于 @mixin ，% ，@function 更多说明可参阅：<br><a href=\"http://sass-lang.com/documentation/file.SASS_REFERENCE.html\">sass文档</a></p>\n<h2 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h2><p>sass 具有运算的特性，可以对数值型的 Value（如：数字、颜色、变量等）进行加减乘除四则运算。请注意运算前后请留一个空格，不然会出错。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$baseFontSize</span>: <span class=\"number\">14px</span> !default;</span><br><span class=\"line\"><span class=\"variable\">$baseLineHeight</span>: <span class=\"number\">1.5</span> !default;</span><br><span class=\"line\"><span class=\"variable\">$baseGap</span>: <span class=\"variable\">$baseFontSize</span> * <span class=\"variable\">$baseLineHeight</span> !default;</span><br><span class=\"line\"><span class=\"selector-class\">.balber</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"variable\">$baseGap</span>;    <span class=\"comment\">//21px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件判断及循环\"><a href=\"#条件判断及循环\" class=\"headerlink\" title=\"条件判断及循环\"></a>条件判断及循环</h2><h3 id=\"if判断\"><a href=\"#if判断\" class=\"headerlink\" title=\"@if判断\"></a>@if判断</h3><p>@if 可一个条件单独使用，也可以和 @else 结合多条件使用。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$lte7</span>: true;</span><br><span class=\"line\"><span class=\"variable\">$type</span>: monster;</span><br><span class=\"line\"><span class=\"selector-class\">.ib</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>:inline-block;</span><br><span class=\"line\">    <span class=\"keyword\">@if</span> <span class=\"variable\">$lte7</span> &#123;</span><br><span class=\"line\">        *<span class=\"attribute\">display</span>:inline;</span><br><span class=\"line\">        *zoom:<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">@if</span> <span class=\"variable\">$type</span> == ocean &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">@else</span> if <span class=\"variable\">$type</span> == matador &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">@else</span> if <span class=\"variable\">$type</span> == monster &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: green;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">@else</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成的 css 如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ib</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">  *<span class=\"attribute\">display</span>: inline;</span><br><span class=\"line\">  *zoom: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三目判断\"><a href=\"#三目判断\" class=\"headerlink\" title=\"三目判断\"></a>三目判断</h3><p>语法为：<code>if($condition,$if_true,$if_false)</code>。<br>三个参数分别表示：条件，条件为真的值，条件为假的值。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">if</span>(true,<span class=\"number\">1px</span>,<span class=\"number\">2px</span>) =&gt; <span class=\"number\">1px</span></span><br><span class=\"line\"><span class=\"built_in\">if</span>(false,<span class=\"number\">1px</span>,<span class=\"number\">2px</span>) =&gt; <span class=\"number\">2px</span> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><p>for 循环有两种形式，分别为：<br><code>@for $var from &lt;start&gt; through &lt;end&gt;</code> 和 <code>@for $var from &lt;start&gt; to &lt;end&gt;</code> 。<br>$i 表示变量，start 表示起始值，end 表示结束值，这两个的区别是关键字 through 表示包括 end 这个数，而 to 则不包括 end 这个数。<br>使用</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@for</span> <span class=\"variable\">$i</span> from <span class=\"number\">1</span> through <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.item-</span>#&#123;<span class=\"variable\">$i</span>&#125; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">2em</span> * <span class=\"variable\">$i</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@for</span> <span class=\"variable\">$i</span> from <span class=\"number\">5</span> to <span class=\"number\">7</span> &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.item-</span>#&#123;<span class=\"variable\">$i</span>&#125; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">2em</span> * <span class=\"variable\">$i</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item-1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">2em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.item-2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">4em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.item-3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">6em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.item-5</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">10em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.item-6</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">12em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"each循环\"><a href=\"#each循环\" class=\"headerlink\" title=\"each循环\"></a>each循环</h3><p>语法为：<code>@each $var in &lt;list or map&gt;</code> 。<br>其中 $var 表示变量，而 list 和 map 表示 list 类型数据和 map 类型数据。sass 3.3.0 新加入了多字段循环和 map 数据循环。</p>\n<h4 id=\"单个字段-list-数据循环\"><a href=\"#单个字段-list-数据循环\" class=\"headerlink\" title=\"单个字段 list 数据循环\"></a>单个字段 list 数据循环</h4><p>使用</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$animal-list</span>: puma, sea-slug, egret, salamander;</span><br><span class=\"line\"><span class=\"keyword\">@each</span> <span class=\"variable\">$animal</span> in <span class=\"variable\">$animal-list</span> &#123;</span><br><span class=\"line\">  .#&#123;<span class=\"variable\">$animal</span>&#125;-<span class=\"attribute\">icon</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: url(<span class=\"string\">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.puma-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&quot;/images/puma.png&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.sea-slug-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&quot;/images/sea-slug.png&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.egret-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&quot;/images/egret.png&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.salamander-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&quot;/images/salamander.png&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多个字段-list-数据循环\"><a href=\"#多个字段-list-数据循环\" class=\"headerlink\" title=\"多个字段 list 数据循环\"></a>多个字段 list 数据循环</h4><p>使用</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$animal-data</span>: (puma, black, default),(sea-slug, blue, pointer),(egret, white, move);</span><br><span class=\"line\"><span class=\"keyword\">@each</span> <span class=\"variable\">$animal</span>, <span class=\"variable\">$color</span>, <span class=\"variable\">$cursor</span> in <span class=\"variable\">$animal-data</span> &#123;</span><br><span class=\"line\">  .#&#123;<span class=\"variable\">$animal</span>&#125;-<span class=\"attribute\">icon</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: url(<span class=\"string\">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid <span class=\"variable\">$color</span>;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: <span class=\"variable\">$cursor</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.puma-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&#x27;/images/puma.png&#x27;</span>);</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>: default; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.sea-slug-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&#x27;/images/sea-slug.png&#x27;</span>);</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid blue;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>: pointer; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.egret-icon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&#x27;/images/egret.png&#x27;</span>);</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid white;</span><br><span class=\"line\">  <span class=\"attribute\">cursor</span>: move; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多个字段-map-数据循环\"><a href=\"#多个字段-map-数据循环\" class=\"headerlink\" title=\"多个字段 map 数据循环\"></a>多个字段 map 数据循环</h4><figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$headings</span>: (h1: <span class=\"number\">2em</span>, h2: <span class=\"number\">1.5em</span>, h3: <span class=\"number\">1.2em</span>);</span><br><span class=\"line\"><span class=\"keyword\">@each</span> <span class=\"variable\">$header</span>, <span class=\"variable\">$size</span> in <span class=\"variable\">$headings</span> &#123;</span><br><span class=\"line\">  #&#123;<span class=\"variable\">$header</span>&#125; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"variable\">$size</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>生成</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">2em</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5em</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2em</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本文介绍了 sass 最基本部分,你可以轻松地使用 sass 编写清晰、无冗余、语义化的 css 。对于 sass 提供的工具你已经有了一个比较深入的了解，同时也掌握了何时使用这些工具的指导原则。</p>\n<p><a href=\"http://sass-lang.com/documentation/file.SASS_REFERENCE.html\">sass文档</a><br><a href=\"http://sass-lang.com/documentation/Sass/Script/Functions.html\">sass函数列表</a><br><a href=\"https://sass-guidelin.es/zh/\">sass guidelines</a></p>\n","categories":["前端"],"tags":["css","sass"]}]